<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 8.3.0" />
    <title>overreact.core API documentation</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2264%22%20height%3D%2264%22%20viewBox%3D%2244.5%202.5%2015%2015%22%3E%3Cpath%20d%3D%22M49.351%2021.041c-.233-.721-.546-2.408-.772-4.076-.042-.09-.067-.187-.046-.288-.166-1.347-.277-2.625-.241-3.351-1.378-1.008-2.271-2.586-2.271-4.362%200-.976.272-1.935.788-2.774.057-.094.122-.18.184-.268-.033-.167-.052-.339-.052-.516%200-1.477%201.202-2.679%202.679-2.679.791%200%201.496.352%201.987.9a6.3%206.3%200%200%201%201.001.029c.492-.564%201.207-.929%202.012-.929%201.477%200%202.679%201.202%202.679%202.679a2.65%202.65%200%200%201-.269%201.148c.383.747.595%201.572.595%202.41%200%202.311-1.507%204.29-3.635%205.107.037.699.147%202.27.423%203.294l.137.461c.156%202.136-4.612%205.166-5.199%203.215zm.127-4.919a4.78%204.78%200%200%200%20.775-.584c-.172-.115-.505-.254-.88-.378zm.331%202.302l.828-.502c-.202-.143-.576-.328-.984-.49zm.45%202.157l.701-.403c-.214-.115-.536-.249-.891-.376l.19.779zM49.13%204.141c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm.735-.389a1.15%201.15%200%200%201%20.314.783%201.16%201.16%200%200%201-1.162%201.162c-.457%200-.842-.27-1.032-.653-.026.117-.042.238-.042.362a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.843-.626-1.535-1.436-1.654zm3.076%201.654a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.037-.009-.072-.011-.109-.21.3-.541.508-.935.508a1.16%201.16%200%200%201-1.162-1.162%201.14%201.14%200%200%201%20.474-.912c-.015%200-.03-.005-.045-.005-.926.001-1.679.754-1.679%201.68zm1.861-1.265c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm1.823%204.823c0-.52-.103-1.035-.288-1.52-.466.394-1.06.64-1.717.64-1.144%200-2.116-.725-2.499-1.738-.383%201.012-1.355%201.738-2.499%201.738-.867%200-1.631-.421-2.121-1.062-.307.605-.478%201.267-.478%201.942%200%202.486%202.153%204.51%204.801%204.51s4.801-2.023%204.801-4.51zm-3.032%209.156l-.146-.492c-.276-1.02-.395-2.457-.444-3.268a6.11%206.11%200%200%201-1.18.115%206.01%206.01%200%200%201-2.536-.562l.006.175c.802.215%201.848.612%202.021%201.25.079.295-.021.601-.274.837l-.598.501c.667.304%201.243.698%201.311%201.179.02.144.022.507-.393.787l-.564.365c1.285.521%201.361.96%201.381%201.126.018.142.011.496-.427.746l-.854.489c.064-1.19%201.985-2.585%202.697-3.248zM49.34%209.925c0-.667%201-.667%201%200%200%20.653.818%201.205%201.787%201.205s1.787-.552%201.787-1.205c0-.667%201-.667%201%200%200%201.216-1.25%202.205-2.787%202.205s-2.787-.989-2.787-2.205zm-.887-7.633c-.093.077-.205.114-.317.114a.5.5%200%200%201-.318-.886L49.183.397a.5.5%200%200%201%20.703.068.5.5%200%200%201-.069.703zm7.661-.065c-.086%200-.173-.022-.253-.068l-1.523-.893c-.575-.337-.069-1.2.506-.863l1.523.892a.5.5%200%200%201%20.179.685c-.094.158-.261.247-.432.247z%22%20fill%3D%22%233bb300%22/%3E%3C/svg%3E"/>

<script>
    window.MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']]
        }
    };
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script>
    /* Re-invoke MathJax when DOM content changes, for example during search. */
    document.addEventListener("DOMContentLoaded", () => {
        new MutationObserver(() => MathJax.typeset()).observe(
            document.querySelector("main.pdoc").parentNode,
            {childList: true}
        );
    })
</script>
<style>/*! * Bootstrap Reboot v5.0.0 (https://getbootstrap.com/) * Copyright 2011-2021 The Bootstrap Authors * Copyright 2011-2021 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus:not(:focus-visible){outline:0}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}select:disabled{opacity:1}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>
<style>/*! pygments syntax highlighting */pre{line-height:125%;}td.linenos pre{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}span.linenos{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}td.linenos pre.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}span.linenos.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}.pdoc .hll{background-color:#ffffcc}.pdoc{background:#f8f8f8;}.pdoc .c{color:#408080; font-style:italic}.pdoc .err{border:1px solid #FF0000}.pdoc .k{color:#008000; font-weight:bold}.pdoc .o{color:#666666}.pdoc .ch{color:#408080; font-style:italic}.pdoc .cm{color:#408080; font-style:italic}.pdoc .cp{color:#BC7A00}.pdoc .cpf{color:#408080; font-style:italic}.pdoc .c1{color:#408080; font-style:italic}.pdoc .cs{color:#408080; font-style:italic}.pdoc .gd{color:#A00000}.pdoc .ge{font-style:italic}.pdoc .gr{color:#FF0000}.pdoc .gh{color:#000080; font-weight:bold}.pdoc .gi{color:#00A000}.pdoc .go{color:#888888}.pdoc .gp{color:#000080; font-weight:bold}.pdoc .gs{font-weight:bold}.pdoc .gu{color:#800080; font-weight:bold}.pdoc .gt{color:#0044DD}.pdoc .kc{color:#008000; font-weight:bold}.pdoc .kd{color:#008000; font-weight:bold}.pdoc .kn{color:#008000; font-weight:bold}.pdoc .kp{color:#008000}.pdoc .kr{color:#008000; font-weight:bold}.pdoc .kt{color:#B00040}.pdoc .m{color:#666666}.pdoc .s{color:#BA2121}.pdoc .na{color:#7D9029}.pdoc .nb{color:#008000}.pdoc .nc{color:#0000FF; font-weight:bold}.pdoc .no{color:#880000}.pdoc .nd{color:#AA22FF}.pdoc .ni{color:#999999; font-weight:bold}.pdoc .ne{color:#D2413A; font-weight:bold}.pdoc .nf{color:#0000FF}.pdoc .nl{color:#A0A000}.pdoc .nn{color:#0000FF; font-weight:bold}.pdoc .nt{color:#008000; font-weight:bold}.pdoc .nv{color:#19177C}.pdoc .ow{color:#AA22FF; font-weight:bold}.pdoc .w{color:#bbbbbb}.pdoc .mb{color:#666666}.pdoc .mf{color:#666666}.pdoc .mh{color:#666666}.pdoc .mi{color:#666666}.pdoc .mo{color:#666666}.pdoc .sa{color:#BA2121}.pdoc .sb{color:#BA2121}.pdoc .sc{color:#BA2121}.pdoc .dl{color:#BA2121}.pdoc .sd{color:#BA2121; font-style:italic}.pdoc .s2{color:#BA2121}.pdoc .se{color:#BB6622; font-weight:bold}.pdoc .sh{color:#BA2121}.pdoc .si{color:#BB6688; font-weight:bold}.pdoc .sx{color:#008000}.pdoc .sr{color:#BB6688}.pdoc .s1{color:#BA2121}.pdoc .ss{color:#19177C}.pdoc .bp{color:#008000}.pdoc .fm{color:#0000FF}.pdoc .vc{color:#19177C}.pdoc .vg{color:#19177C}.pdoc .vi{color:#19177C}.pdoc .vm{color:#19177C}.pdoc .il{color:#666666}</style>
<style>/*! pdoc */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f7f7f7;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}body{background-color:var(--pdoc-background);}html, body{width:100%;height:100%;}@media (max-width:769px){#navtoggle{cursor:pointer;position:absolute;width:50px;height:40px;top:1rem;right:1rem;border-color:var(--text);color:var(--text);display:flex;opacity:0.8;}#navtoggle:hover{opacity:1;}#togglestate + div{display:none;}#togglestate:checked + div{display:inherit;}main, header{padding:2rem 3vw;}.git-button{display:none !important;}nav input[type="search"]:valid ~ *{display:none !important;}}@media (min-width:770px){:root{--sidebar-width:clamp(12.5rem, 28vw, 22rem);}nav{position:fixed;overflow:auto;height:100vh;width:var(--sidebar-width);}main, header{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);width:calc(54rem + var(--sidebar-width));max-width:100%;}#navtoggle{display:none;}}#togglestate{display:none;}nav.pdoc{--pad:1.75rem;--indent:1.5rem;background-color:var(--accent);border-right:1px solid var(--accent2);box-shadow:0 0 20px rgba(50, 50, 50, .2) inset;padding:0 0 0 var(--pad);overflow-wrap:anywhere;scrollbar-width:thin; scrollbar-color:var(--accent2) transparent }nav.pdoc::-webkit-scrollbar{width:.4rem; }nav.pdoc::-webkit-scrollbar-thumb{background-color:var(--accent2); }nav.pdoc > div{padding:var(--pad) 0;}nav.pdoc .module-list-button{display:inline-flex;align-items:center;color:var(--text);border-color:var(--muted);margin-bottom:1rem;}nav.pdoc .module-list-button:hover{border-color:var(--text);}nav.pdoc input[type=search]{display:block;outline-offset:0;width:calc(100% - var(--pad));}nav.pdoc .logo{max-width:calc(100% - var(--pad));max-height:35vh;display:block;margin:0 auto 1rem;transform:translate(calc(-.5 * var(--pad)), 0);}nav.pdoc ul{list-style:none;padding-left:0;}nav.pdoc li{display:block;margin:0;padding:.2rem 0 .2rem var(--indent);transition:all 100ms;}nav.pdoc > div > ul > li{padding-left:0;}nav.pdoc li:hover{background-color:var(--nav-hover);}nav.pdoc a, nav.pdoc a:hover{color:var(--text);}nav.pdoc a{display:block;}nav.pdoc > h2:first-of-type{margin-top:1.5rem;}nav.pdoc .class:before{content:"class ";color:var(--muted);}nav.pdoc .function:after{content:"()";color:var(--muted);}nav.pdoc footer:before{content:"";display:block;width:calc(100% - var(--pad));border-top:solid var(--accent2) 1px;margin-top:1.5rem;padding-top:.5rem;}nav.pdoc footer{font-size:small;}html, main{scroll-behavior:smooth;}.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{background-color:var(--code);border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.pdoc details{filter:opacity(1);}.pdoc details:not([open]){height:0;}.pdoc details > summary{position:absolute;top:-35px;right:0;font-size:.75rem;color:var(--muted);padding:0 .7em;user-select:none;}.pdoc details > summary:focus{outline:0;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc > section:first-of-type > .docstring{margin-bottom:2.5rem;}.pdoc .docstring pre{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc .headerlink{position:absolute;width:0;margin-left:-1.5rem;line-height:1.4rem;font-size:1.5rem;font-weight:normal;transition:all 100ms ease-in-out;opacity:0;user-select:none;}.pdoc .attr > .headerlink{margin-left:-2.5rem;}.pdoc *:hover > .headerlink,.pdoc *:target > .attr > .headerlink{opacity:1;}.pdoc .attr{display:block;color:var(--text);margin:.5rem 0 .5rem;padding:.4rem 5rem .4rem 1rem;background-color:var(--accent);}.pdoc .classattr{margin-left:2rem;}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{white-space:pre-wrap;}.pdoc .annotation{color:var(--annotation);}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .search-result .docstring{overflow:auto;max-height:25vh;}.pdoc .search-result.focused > .attr{background-color:var(--active);}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}.pdoc table{display:block;width:max-content;max-width:100%;overflow:auto;margin-bottom:1rem;}.pdoc table th{font-weight:600;}.pdoc table th, .pdoc table td{padding:6px 13px;border:1px solid var(--accent2);}</style>
</head>
<body>        <nav class="pdoc">
            <label id="navtoggle" for="togglestate" class="pdoc-button"><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke-linecap='round' stroke="currentColor" stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg></label>
            <input id="togglestate" type="checkbox">
            <div>
                        <a class="pdoc-button module-list-button" href="../overreact.html">
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-box-arrow-in-left" viewBox="0 0 16 16">
  <path fill-rule="evenodd" d="M10 3.5a.5.5 0 0 0-.5-.5h-8a.5.5 0 0 0-.5.5v9a.5.5 0 0 0 .5.5h8a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 1 1 0v2A1.5 1.5 0 0 1 9.5 14h-8A1.5 1.5 0 0 1 0 12.5v-9A1.5 1.5 0 0 1 1.5 2h8A1.5 1.5 0 0 1 11 3.5v2a.5.5 0 0 1-1 0v-2z"/>
  <path fill-rule="evenodd" d="M4.146 8.354a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H14.5a.5.5 0 0 1 0 1H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3z"/>
</svg>                            &nbsp;overreact</a>

<a href="/overreact">                        <img src="https://raw.githubusercontent.com/geem-lab/overreact-guide/master/logo.png" class="logo" alt="project logo"/>
</a>
                        <input type="search" placeholder="Search..." role="searchbox" aria-label="search"
                               pattern=".+" required>



                    <h2>API Documentation</h2>
                        <ul class="memberlist">
            <li>
                    <a class="class" href="#Scheme">Scheme</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#Scheme.__init__">Scheme</a>
                        </li>
                        <li>
                                <a class="variable" href="#Scheme.compounds">compounds</a>
                        </li>
                        <li>
                                <a class="variable" href="#Scheme.reactions">reactions</a>
                        </li>
                        <li>
                                <a class="variable" href="#Scheme.is_half_equilibrium">is_half_equilibrium</a>
                        </li>
                        <li>
                                <a class="variable" href="#Scheme.A">A</a>
                        </li>
                        <li>
                                <a class="variable" href="#Scheme.B">B</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="function" href="#parse_reactions">parse_reactions</a>
            </li>
    </ul>


                    <footer>overreact</footer>

                    <a class="attribution" title="pdoc: Python API documentation generator" href="https://pdoc.dev">
                        built with <span class="visually-hidden">pdoc</span><img
                            alt="pdoc logo"
                            src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20role%3D%22img%22%20aria-label%3D%22pdoc%20logo%22%20width%3D%22300%22%20height%3D%22150%22%20viewBox%3D%22-1%200%2060%2030%22%3E%3Ctitle%3Epdoc%3C/title%3E%3Cpath%20d%3D%22M29.621%2021.293c-.011-.273-.214-.475-.511-.481a.5.5%200%200%200-.489.503l-.044%201.393c-.097.551-.695%201.215-1.566%201.704-.577.428-1.306.486-2.193.182-1.426-.617-2.467-1.654-3.304-2.487l-.173-.172a3.43%203.43%200%200%200-.365-.306.49.49%200%200%200-.286-.196c-1.718-1.06-4.931-1.47-7.353.191l-.219.15c-1.707%201.187-3.413%202.131-4.328%201.03-.02-.027-.49-.685-.141-1.763.233-.721.546-2.408.772-4.076.042-.09.067-.187.046-.288.166-1.347.277-2.625.241-3.351%201.378-1.008%202.271-2.586%202.271-4.362%200-.976-.272-1.935-.788-2.774-.057-.094-.122-.18-.184-.268.033-.167.052-.339.052-.516%200-1.477-1.202-2.679-2.679-2.679-.791%200-1.496.352-1.987.9a6.3%206.3%200%200%200-1.001.029c-.492-.564-1.207-.929-2.012-.929-1.477%200-2.679%201.202-2.679%202.679A2.65%202.65%200%200%200%20.97%206.554c-.383.747-.595%201.572-.595%202.41%200%202.311%201.507%204.29%203.635%205.107-.037.699-.147%202.27-.423%203.294l-.137.461c-.622%202.042-2.515%208.257%201.727%2010.643%201.614.908%203.06%201.248%204.317%201.248%202.665%200%204.492-1.524%205.322-2.401%201.476-1.559%202.886-1.854%206.491.82%201.877%201.393%203.514%201.753%204.861%201.068%202.223-1.713%202.811-3.867%203.399-6.374.077-.846.056-1.469.054-1.537zm-4.835%204.313c-.054.305-.156.586-.242.629-.034-.007-.131-.022-.307-.157-.145-.111-.314-.478-.456-.908.221.121.432.25.675.355.115.039.219.051.33.081zm-2.251-1.238c-.05.33-.158.648-.252.694-.022.001-.125-.018-.307-.157-.217-.166-.488-.906-.639-1.573.358.344.754.693%201.198%201.036zm-3.887-2.337c-.006-.116-.018-.231-.041-.342.635.145%201.189.368%201.599.625.097.231.166.481.174.642-.03.049-.055.101-.067.158-.046.013-.128.026-.298.004-.278-.037-.901-.57-1.367-1.087zm-1.127-.497c.116.306.176.625.12.71-.019.014-.117.045-.345.016-.206-.027-.604-.332-.986-.695.41-.051.816-.056%201.211-.031zm-4.535%201.535c.209.22.379.47.358.598-.006.041-.088.138-.351.234-.144.055-.539-.063-.979-.259a11.66%2011.66%200%200%200%20.972-.573zm.983-.664c.359-.237.738-.418%201.126-.554.25.237.479.548.457.694-.006.042-.087.138-.351.235-.174.064-.694-.105-1.232-.375zm-3.381%201.794c-.022.145-.061.29-.149.401-.133.166-.358.248-.69.251h-.002c-.133%200-.306-.26-.45-.621.417.091.854.07%201.291-.031zm-2.066-8.077a4.78%204.78%200%200%201-.775-.584c.172-.115.505-.254.88-.378l-.105.962zm-.331%202.302a10.32%2010.32%200%200%201-.828-.502c.202-.143.576-.328.984-.49l-.156.992zm-.45%202.157l-.701-.403c.214-.115.536-.249.891-.376a11.57%2011.57%200%200%201-.19.779zm-.181%201.716c.064.398.194.702.298.893-.194-.051-.435-.162-.736-.398.061-.119.224-.3.438-.495zM8.87%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zm-.735-.389a1.15%201.15%200%200%200-.314.783%201.16%201.16%200%200%200%201.162%201.162c.457%200%20.842-.27%201.032-.653.026.117.042.238.042.362a1.68%201.68%200%200%201-1.679%201.679%201.68%201.68%200%200%201-1.679-1.679c0-.843.626-1.535%201.436-1.654zM5.059%205.406A1.68%201.68%200%200%201%203.38%207.085a1.68%201.68%200%200%201-1.679-1.679c0-.037.009-.072.011-.109.21.3.541.508.935.508a1.16%201.16%200%200%200%201.162-1.162%201.14%201.14%200%200%200-.474-.912c.015%200%20.03-.005.045-.005.926.001%201.679.754%201.679%201.68zM3.198%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zM1.375%208.964c0-.52.103-1.035.288-1.52.466.394%201.06.64%201.717.64%201.144%200%202.116-.725%202.499-1.738.383%201.012%201.355%201.738%202.499%201.738.867%200%201.631-.421%202.121-1.062.307.605.478%201.267.478%201.942%200%202.486-2.153%204.51-4.801%204.51s-4.801-2.023-4.801-4.51zm24.342%2019.349c-.985.498-2.267.168-3.813-.979-3.073-2.281-5.453-3.199-7.813-.705-1.315%201.391-4.163%203.365-8.423.97-3.174-1.786-2.239-6.266-1.261-9.479l.146-.492c.276-1.02.395-2.457.444-3.268a6.11%206.11%200%200%200%201.18.115%206.01%206.01%200%200%200%202.536-.562l-.006.175c-.802.215-1.848.612-2.021%201.25-.079.295.021.601.274.837.219.203.415.364.598.501-.667.304-1.243.698-1.311%201.179-.02.144-.022.507.393.787.213.144.395.26.564.365-1.285.521-1.361.96-1.381%201.126-.018.142-.011.496.427.746l.854.489c-.473.389-.971.914-.999%201.429-.018.278.095.532.316.713.675.556%201.231.721%201.653.721.059%200%20.104-.014.158-.02.207.707.641%201.64%201.513%201.64h.013c.8-.008%201.236-.345%201.462-.626.173-.216.268-.457.325-.692.424.195.93.374%201.372.374.151%200%20.294-.021.423-.068.732-.27.944-.704.993-1.021.009-.061.003-.119.002-.179.266.086.538.147.789.147.15%200%20.294-.021.423-.069.542-.2.797-.489.914-.754.237.147.478.258.704.288.106.014.205.021.296.021.356%200%20.595-.101.767-.229.438.435%201.094.992%201.656%201.067.106.014.205.021.296.021a1.56%201.56%200%200%200%20.323-.035c.17.575.453%201.289.866%201.605.358.273.665.362.914.362a.99.99%200%200%200%20.421-.093%201.03%201.03%200%200%200%20.245-.164c.168.428.39.846.68%201.068.358.273.665.362.913.362a.99.99%200%200%200%20.421-.093c.317-.148.512-.448.639-.762.251.157.495.257.726.257.127%200%20.25-.024.37-.071.427-.17.706-.617.841-1.314.022-.015.047-.022.068-.038.067-.051.133-.104.196-.159-.443%201.486-1.107%202.761-2.086%203.257zM8.66%209.925a.5.5%200%201%200-1%200c0%20.653-.818%201.205-1.787%201.205s-1.787-.552-1.787-1.205a.5.5%200%201%200-1%200c0%201.216%201.25%202.205%202.787%202.205s2.787-.989%202.787-2.205zm4.4%2015.965l-.208.097c-2.661%201.258-4.708%201.436-6.086.527-1.542-1.017-1.88-3.19-1.844-4.198a.4.4%200%200%200-.385-.414c-.242-.029-.406.164-.414.385-.046%201.249.367%203.686%202.202%204.896.708.467%201.547.7%202.51.7%201.248%200%202.706-.392%204.362-1.174l.185-.086a.4.4%200%200%200%20.205-.527c-.089-.204-.326-.291-.527-.206zM9.547%202.292c.093.077.205.114.317.114a.5.5%200%200%200%20.318-.886L8.817.397a.5.5%200%200%200-.703.068.5.5%200%200%200%20.069.703l1.364%201.124zm-7.661-.065c.086%200%20.173-.022.253-.068l1.523-.893a.5.5%200%200%200-.506-.863l-1.523.892a.5.5%200%200%200-.179.685c.094.158.261.247.432.247z%22%20transform%3D%22matrix%28-1%200%200%201%2058%200%29%22%20fill%3D%22%233bb300%22/%3E%3Cpath%20d%3D%22M.3%2021.86V10.18q0-.46.02-.68.04-.22.18-.5.28-.54%201.34-.54%201.06%200%201.42.28.38.26.44.78.76-1.04%202.38-1.04%201.64%200%203.1%201.54%201.46%201.54%201.46%203.58%200%202.04-1.46%203.58-1.44%201.54-3.08%201.54-1.64%200-2.38-.92v4.04q0%20.46-.04.68-.02.22-.18.5-.14.3-.5.42-.36.12-.98.12-.62%200-1-.12-.36-.12-.52-.4-.14-.28-.18-.5-.02-.22-.02-.68zm3.96-9.42q-.46.54-.46%201.18%200%20.64.46%201.18.48.52%201.2.52.74%200%201.24-.52.52-.52.52-1.18%200-.66-.48-1.18-.48-.54-1.26-.54-.76%200-1.22.54zm14.741-8.36q.16-.3.54-.42.38-.12%201-.12.64%200%201.02.12.38.12.52.42.16.3.18.54.04.22.04.68v11.94q0%20.46-.04.7-.02.22-.18.5-.3.54-1.7.54-1.38%200-1.54-.98-.84.96-2.34.96-1.8%200-3.28-1.56-1.48-1.58-1.48-3.66%200-2.1%201.48-3.68%201.5-1.58%203.28-1.58%201.48%200%202.3%201v-4.2q0-.46.02-.68.04-.24.18-.52zm-3.24%2010.86q.52.54%201.26.54.74%200%201.22-.54.5-.54.5-1.18%200-.66-.48-1.22-.46-.56-1.26-.56-.8%200-1.28.56-.48.54-.48%201.2%200%20.66.52%201.2zm7.833-1.2q0-2.4%201.68-3.96%201.68-1.56%203.84-1.56%202.16%200%203.82%201.56%201.66%201.54%201.66%203.94%200%201.66-.86%202.96-.86%201.28-2.1%201.9-1.22.6-2.54.6-1.32%200-2.56-.64-1.24-.66-2.1-1.92-.84-1.28-.84-2.88zm4.18%201.44q.64.48%201.3.48.66%200%201.32-.5.66-.5.66-1.48%200-.98-.62-1.46-.62-.48-1.34-.48-.72%200-1.34.5-.62.5-.62%201.48%200%20.96.64%201.46zm11.412-1.44q0%20.84.56%201.32.56.46%201.18.46.64%200%201.18-.36.56-.38.9-.38.6%200%201.46%201.06.46.58.46%201.04%200%20.76-1.1%201.42-1.14.8-2.8.8-1.86%200-3.58-1.34-.82-.64-1.34-1.7-.52-1.08-.52-2.36%200-1.3.52-2.34.52-1.06%201.34-1.7%201.66-1.32%203.54-1.32.76%200%201.48.22.72.2%201.06.4l.32.2q.36.24.56.38.52.4.52.92%200%20.5-.42%201.14-.72%201.1-1.38%201.1-.38%200-1.08-.44-.36-.34-1.04-.34-.66%200-1.24.48-.58.48-.58%201.34z%22%20fill%3D%22green%22/%3E%3C/svg%3E"/>
                    </a>
            </div>
        </nav>
    <main class="pdoc">
            <section>
                        <a class="pdoc-button git-button" href="https://github.com/geem-lab/overreact/blob/main/overreact/core.py">Edit on GitHub</a>
                    <h1 class="modulename">
<a href="./../overreact.html">overreact</a><wbr>.core    </h1>

                        <div class="docstring"><p>Module dedicated to parsing and modeling of chemical reaction networks.</p>
</div>

                        <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="ch">#!/usr/bin/env python3</span>

<span class="sd">&quot;&quot;&quot;Module dedicated to parsing and modeling of chemical reaction networks.&quot;&quot;&quot;</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Scheme&quot;</span><span class="p">,</span> <span class="s2">&quot;parse_reactions&quot;</span><span class="p">]</span>


<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NamedTuple</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Text</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">overreact</span> <span class="k">as</span> <span class="nn">rx</span>


<span class="k">class</span> <span class="nc">Scheme</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A descriptor of a chemical reaction network.</span>

<span class="sd">    Mostly likely, this comes from a parsed input file.</span>
<span class="sd">    See `overreact.io.parse_model`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">compounds</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Text</span><span class="p">]</span>
    <span class="sd">&quot;&quot;&quot;A descriptor of compounds.&quot;&quot;&quot;</span>
    <span class="n">reactions</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Text</span><span class="p">]</span>
    <span class="sd">&quot;&quot;&quot;A descriptor of reactions.&quot;&quot;&quot;</span>
    <span class="n">is_half_equilibrium</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span>
    <span class="sd">&quot;&quot;&quot;An indicator of whether a reaction is half-equilibrium.&quot;&quot;&quot;</span>
    <span class="n">A</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="sd">&quot;&quot;&quot;A matrix of stoichiometric coefficients between reactants and products.&quot;&quot;&quot;</span>
    <span class="n">B</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="sd">&quot;&quot;&quot;A matrix of stoichiometric coefficients between reactants and transition states.&quot;&quot;&quot;</span>


<span class="n">_abbr_environment</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;dcm&quot;</span><span class="p">:</span> <span class="s2">&quot;dichloromethane&quot;</span><span class="p">,</span>
    <span class="s2">&quot;dmf&quot;</span><span class="p">:</span> <span class="s2">&quot;n,n-dimethylformamide&quot;</span><span class="p">,</span>
    <span class="s2">&quot;dmso&quot;</span><span class="p">:</span> <span class="s2">&quot;dimethylsulfoxide&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ccl4&quot;</span><span class="p">:</span> <span class="s2">&quot;carbon tetrachloride&quot;</span><span class="p">,</span>
    <span class="s2">&quot;g&quot;</span><span class="p">:</span> <span class="s2">&quot;gas&quot;</span><span class="p">,</span>
    <span class="s2">&quot;mecn&quot;</span><span class="p">:</span> <span class="s2">&quot;acetonitrile&quot;</span><span class="p">,</span>
    <span class="s2">&quot;meno2&quot;</span><span class="p">:</span> <span class="s2">&quot;nitromethane&quot;</span><span class="p">,</span>
    <span class="s2">&quot;phno2&quot;</span><span class="p">:</span> <span class="s2">&quot;nitrobenzene&quot;</span><span class="p">,</span>
    <span class="s2">&quot;s&quot;</span><span class="p">:</span> <span class="s2">&quot;solid&quot;</span><span class="p">,</span>
    <span class="s2">&quot;thf&quot;</span><span class="p">:</span> <span class="s2">&quot;tetrahydrofuran&quot;</span><span class="p">,</span>
    <span class="s2">&quot;w&quot;</span><span class="p">:</span> <span class="s2">&quot;water&quot;</span><span class="p">,</span>
<span class="p">}</span>


<span class="k">def</span> <span class="nf">_check_scheme</span><span class="p">(</span><span class="n">scheme_or_text</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Scheme</span><span class="p">,</span> <span class="n">Text</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Scheme</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Interface transparently between strings and schemes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    scheme_or_text : Scheme or str</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Scheme</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; _check_scheme(&quot;A -&gt; B&quot;)</span>
<span class="sd">    Scheme(compounds=(&#39;A&#39;, &#39;B&#39;),</span>
<span class="sd">           reactions=(&#39;A -&gt; B&#39;,),</span>
<span class="sd">           is_half_equilibrium=(False,),</span>
<span class="sd">           A=((-1.,), (1.,)),</span>
<span class="sd">           B=((-1.,), (1.,)))</span>
<span class="sd">    &gt;&gt;&gt; _check_scheme(_check_scheme(&quot;A -&gt; B&quot;))</span>
<span class="sd">    Scheme(compounds=(&#39;A&#39;, &#39;B&#39;),</span>
<span class="sd">           reactions=(&#39;A -&gt; B&#39;,),</span>
<span class="sd">           is_half_equilibrium=(False,),</span>
<span class="sd">           A=((-1.,), (1.,)),</span>
<span class="sd">           B=((-1.,), (1.,)))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scheme_or_text</span><span class="p">,</span> <span class="n">Scheme</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">scheme_or_text</span>
    <span class="k">return</span> <span class="n">parse_reactions</span><span class="p">(</span><span class="n">scheme_or_text</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_transition_states</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">is_half_equilibrium</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the indices of transition states for each reaction.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A, B : array-like</span>
<span class="sd">    is_half_equilibrium : sequence</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sequence</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; scheme = parse_reactions(&quot;A -&gt; B&quot;)</span>
<span class="sd">    &gt;&gt;&gt; print(scheme)</span>
<span class="sd">    Scheme(compounds=(&#39;A&#39;, &#39;B&#39;),</span>
<span class="sd">           reactions=(&#39;A -&gt; B&#39;,),</span>
<span class="sd">           is_half_equilibrium=(False,),</span>
<span class="sd">           A=((-1.,), (1.,)),</span>
<span class="sd">           B=((-1.,), (1.,)))</span>
<span class="sd">    &gt;&gt;&gt; get_transition_states(scheme.A, scheme.B, scheme.is_half_equilibrium)</span>
<span class="sd">    (None,)</span>

<span class="sd">    &gt;&gt;&gt; scheme = parse_reactions(&quot;S -&gt; E‡ -&gt; S&quot;)</span>
<span class="sd">    &gt;&gt;&gt; print(scheme)</span>
<span class="sd">    Scheme(compounds=(&#39;S&#39;, &#39;E‡&#39;),</span>
<span class="sd">           reactions=(&#39;S -&gt; S&#39;,),</span>
<span class="sd">           is_half_equilibrium=(False,),</span>
<span class="sd">           A=((0.,), (0.,)),</span>
<span class="sd">           B=((-1.,), (1.,)))</span>
<span class="sd">    &gt;&gt;&gt; get_transition_states(scheme.A, scheme.B, scheme.is_half_equilibrium)</span>
<span class="sd">    (1,)</span>

<span class="sd">    &gt;&gt;&gt; scheme = parse_reactions(&quot;E + S &lt;=&gt; ES -&gt; ES‡ -&gt; E + P&quot;)</span>
<span class="sd">    &gt;&gt;&gt; print(scheme)</span>
<span class="sd">    Scheme(compounds=(&#39;E&#39;, &#39;S&#39;, &#39;ES&#39;, &#39;ES‡&#39;, &#39;P&#39;),</span>
<span class="sd">           reactions=(&#39;E + S -&gt; ES&#39;, &#39;ES -&gt; E + S&#39;, &#39;ES -&gt; E + P&#39;),</span>
<span class="sd">           is_half_equilibrium=(True,  True, False),</span>
<span class="sd">           A=((-1.,  1.,  1.),</span>
<span class="sd">              (-1.,  1.,  0.),</span>
<span class="sd">              (1., -1., -1.),</span>
<span class="sd">              (0.,  0.,  0.),</span>
<span class="sd">              (0.,  0.,  1.)),</span>
<span class="sd">           B=((-1.,  0.,  0.),</span>
<span class="sd">              (-1.,  0.,  0.),</span>
<span class="sd">              (1.,  0., -1.),</span>
<span class="sd">              (0.,  0.,  1.),</span>
<span class="sd">              (0.,  0.,  0.)))</span>
<span class="sd">    &gt;&gt;&gt; get_transition_states(scheme.A, scheme.B, scheme.is_half_equilibrium)</span>
<span class="sd">    (None, None, 3)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>  <span class="c1"># transition state matrix</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span>
        <span class="n">x</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">is_half_equilibrium</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">tau</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
    <span class="p">)</span>


<span class="c1"># TODO(schneiderfelipe): some of the more esoteric doctests should become</span>
<span class="c1"># real tests.</span>
<span class="k">def</span> <span class="nf">unparse_reactions</span><span class="p">(</span><span class="n">scheme</span><span class="p">:</span> <span class="n">Scheme</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Text</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Unparse a kinetic model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    scheme : Scheme</span>
<span class="sd">        A descriptor of the reaction scheme.</span>
<span class="sd">        Mostly likely, this comes from a parsed input file.</span>
<span class="sd">        See `overreact.io.parse_model`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    text : str</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function assumes complimentary half equilibria are located one after</span>
<span class="sd">    the other in ``scheme.reactions``, which is to be expected from</span>
<span class="sd">    `parse_reactions`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; unparse_reactions(Scheme(compounds=(&#39;A&#39;, &#39;B&#39;), reactions=(&#39;A -&gt; B&#39;,),</span>
<span class="sd">    ...                   is_half_equilibrium=(False,),</span>
<span class="sd">    ...                   A=((-1.,),</span>
<span class="sd">    ...                      ( 1.,)),</span>
<span class="sd">    ...                   B=((-1.,),</span>
<span class="sd">    ...                      ( 1.,))))</span>
<span class="sd">    &#39;A -&gt; B&#39;</span>
<span class="sd">    &gt;&gt;&gt; unparse_reactions(Scheme(compounds=(&#39;A&#39;, &#39;B&#39;),</span>
<span class="sd">    ...                   reactions=(&#39;A -&gt; B&#39;, &#39;B -&gt; A&#39;),</span>
<span class="sd">    ...                   is_half_equilibrium=(True, True),</span>
<span class="sd">    ...                   A=((-1.,  1.),</span>
<span class="sd">    ...                      ( 1., -1.)),</span>
<span class="sd">    ...                   B=((-1.,  0.),</span>
<span class="sd">    ...                      ( 1.,  0.))))</span>
<span class="sd">    &#39;A &lt;=&gt; B&#39;</span>
<span class="sd">    &gt;&gt;&gt; unparse_reactions(Scheme(compounds=(&#39;A&#39;, &#39;A‡&#39;, &#39;B&#39;),</span>
<span class="sd">    ...                   reactions=(&#39;A -&gt; B&#39;,),</span>
<span class="sd">    ...                   is_half_equilibrium=(False,),</span>
<span class="sd">    ...                   A=((-1.,),</span>
<span class="sd">    ...                      ( 0.,),</span>
<span class="sd">    ...                      ( 1.,)),</span>
<span class="sd">    ...                   B=((-1.,),</span>
<span class="sd">    ...                      ( 1.,),</span>
<span class="sd">    ...                      ( 0.,))))</span>
<span class="sd">    &#39;A -&gt; A‡ -&gt; B&#39;</span>
<span class="sd">    &gt;&gt;&gt; print(unparse_reactions(Scheme(compounds=(&#39;B&#39;, &#39;B‡&#39;, &#39;C&#39;, &#39;D&#39;, &quot;B&#39;‡&quot;,</span>
<span class="sd">    ...                                           &#39;E&#39;, &#39;A&#39;),</span>
<span class="sd">    ...                         reactions=(&#39;B -&gt; C&#39;, &#39;B -&gt; D&#39;, &#39;B -&gt; E&#39;,</span>
<span class="sd">    ...                                    &#39;A -&gt; C&#39;, &#39;A -&gt; D&#39;),</span>
<span class="sd">    ...                         is_half_equilibrium=(False, False, False,</span>
<span class="sd">    ...                                              False, False),</span>
<span class="sd">    ...                         A=((-1., -1., -1.,  0.,  0.),</span>
<span class="sd">    ...                            ( 0.,  0.,  0.,  0.,  0.),</span>
<span class="sd">    ...                            ( 1.,  0.,  0.,  1.,  0.),</span>
<span class="sd">    ...                            ( 0.,  1.,  0.,  0.,  1.),</span>
<span class="sd">    ...                            ( 0.,  0.,  0.,  0.,  0.),</span>
<span class="sd">    ...                            ( 0.,  0.,  1.,  0.,  0.),</span>
<span class="sd">    ...                            ( 0.,  0.,  0., -1., -1.)),</span>
<span class="sd">    ...                         B=((-1., -1., -1.,  0.,  0.),</span>
<span class="sd">    ...                            ( 1.,  1.,  0.,  1.,  1.),</span>
<span class="sd">    ...                            ( 0.,  0.,  0.,  0.,  0.),</span>
<span class="sd">    ...                            ( 0.,  0.,  0.,  0.,  0.),</span>
<span class="sd">    ...                            ( 0.,  0.,  1.,  0.,  0.),</span>
<span class="sd">    ...                            ( 0.,  0.,  0.,  0.,  0.),</span>
<span class="sd">    ...                            ( 0.,  0.,  0., -1., -1.)))))</span>
<span class="sd">    B -&gt; B‡ -&gt; C</span>
<span class="sd">    B -&gt; B‡ -&gt; D</span>
<span class="sd">    B -&gt; B&#39;‡ -&gt; E</span>
<span class="sd">    A -&gt; B‡ -&gt; C</span>
<span class="sd">    A -&gt; B‡ -&gt; D</span>
<span class="sd">    &gt;&gt;&gt; print(unparse_reactions(Scheme(compounds=(&#39;A&#39;, &#39;A‡&#39;, &#39;B&#39;),</span>
<span class="sd">    ...                         reactions=(&#39;A -&gt; B&#39;, &#39;A -&gt; B&#39;),</span>
<span class="sd">    ...                         is_half_equilibrium=(False, False),</span>
<span class="sd">    ...                         A=((-1., -1.),</span>
<span class="sd">    ...                            ( 0.,  0.),</span>
<span class="sd">    ...                            ( 1.,  1.)),</span>
<span class="sd">    ...                         B=((-1., -1.),</span>
<span class="sd">    ...                            ( 1.,  0.),</span>
<span class="sd">    ...                            ( 0.,  1.)))))</span>
<span class="sd">    A -&gt; A‡ -&gt; B</span>
<span class="sd">    A -&gt; B</span>
<span class="sd">    &gt;&gt;&gt; unparse_reactions(Scheme(compounds=(&#39;A&#39;, &#39;A‡&#39;, &quot;A&#39;‡&quot;, &#39;B&#39;),</span>
<span class="sd">    ...                   reactions=(&quot;A -&gt; A&#39;‡&quot;,),</span>
<span class="sd">    ...                   is_half_equilibrium=(False,),</span>
<span class="sd">    ...                   A=((-1.,),</span>
<span class="sd">    ...                      ( 0.,),</span>
<span class="sd">    ...                      ( 1.,),</span>
<span class="sd">    ...                      ( 0.,)),</span>
<span class="sd">    ...                   B=((-1.,),</span>
<span class="sd">    ...                      ( 1.,),</span>
<span class="sd">    ...                      ( 0.,),</span>
<span class="sd">    ...                      ( 0.,))))</span>
<span class="sd">    &quot;A -&gt; A‡ -&gt; A&#39;‡&quot;</span>
<span class="sd">    &gt;&gt;&gt; unparse_reactions(Scheme(compounds=(&#39;S&#39;, &#39;E‡&#39;),</span>
<span class="sd">    ...                   reactions=(&#39;S -&gt; S&#39;,),</span>
<span class="sd">    ...                   is_half_equilibrium=(False,),</span>
<span class="sd">    ...                   A=((0.0,),</span>
<span class="sd">    ...                      (0.0,)),</span>
<span class="sd">    ...                   B=((-1.0,),</span>
<span class="sd">    ...                      (1.0,))))</span>
<span class="sd">    &#39;S -&gt; E‡ -&gt; S&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">scheme</span> <span class="o">=</span> <span class="n">_check_scheme</span><span class="p">(</span><span class="n">scheme</span><span class="p">)</span>
    <span class="n">transition_states</span> <span class="o">=</span> <span class="n">get_transition_states</span><span class="p">(</span>
        <span class="n">scheme</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">scheme</span><span class="o">.</span><span class="n">B</span><span class="p">,</span> <span class="n">scheme</span><span class="o">.</span><span class="n">is_half_equilibrium</span>
    <span class="p">)</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">scheme</span><span class="o">.</span><span class="n">reactions</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">transition_states</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">scheme</span><span class="o">.</span><span class="n">reactions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;-&gt;&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;-&gt; </span><span class="si">{</span><span class="n">scheme</span><span class="o">.</span><span class="n">compounds</span><span class="p">[</span><span class="n">transition_states</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="si">}</span><span class="s2"> -&gt;&quot;</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">scheme</span><span class="o">.</span><span class="n">is_half_equilibrium</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scheme</span><span class="o">.</span><span class="n">reactions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;-&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;=&gt;&quot;</span><span class="p">))</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># avoid backward reaction, which comes next</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scheme</span><span class="o">.</span><span class="n">reactions</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_environment</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Retrieve a compound&#39;s environment by its name.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    str</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; _get_environment(&quot;pyrrole&quot;)</span>
<span class="sd">    &#39;gas&#39;</span>

<span class="sd">    By default, compounds are assumed to be in gas phase, but you can give a</span>
<span class="sd">    special tag to specify the solvent:</span>

<span class="sd">    &gt;&gt;&gt; _get_environment(&quot;pyrrole(water)&quot;)</span>
<span class="sd">    &#39;water&#39;</span>
<span class="sd">    &gt;&gt;&gt; _get_environment(&quot;pyrrole(dichloromethane)&quot;)</span>
<span class="sd">    &#39;dichloromethane&#39;</span>

<span class="sd">    Some abbreviations are accepted, such as &quot;w&quot; for water:</span>

<span class="sd">    &gt;&gt;&gt; _get_environment(&quot;pyrrole(w)&quot;)</span>
<span class="sd">    &#39;water&#39;</span>
<span class="sd">    &gt;&gt;&gt; _get_environment(&quot;pyrrole(dcm)&quot;)</span>
<span class="sd">    &#39;dichloromethane&#39;</span>

<span class="sd">    You can indicate a phase as usual, although solids are currently not</span>
<span class="sd">    supported in overreact:</span>

<span class="sd">    &gt;&gt;&gt; _get_environment(&quot;pyrrole(solid)&quot;)</span>
<span class="sd">    &#39;solid&#39;</span>
<span class="sd">    &gt;&gt;&gt; _get_environment(&quot;pyrrole(s)&quot;)</span>
<span class="sd">    &#39;solid&#39;</span>
<span class="sd">    &gt;&gt;&gt; _get_environment(&quot;pyrrole(gas)&quot;)</span>
<span class="sd">    &#39;gas&#39;</span>
<span class="sd">    &gt;&gt;&gt; _get_environment(&quot;pyrrole(g)&quot;)</span>
<span class="sd">    &#39;gas&#39;</span>

<span class="sd">    For the case of liquids, the returned environment is the name of the</span>
<span class="sd">    compound (abbreviations are applied as usual):</span>

<span class="sd">    &gt;&gt;&gt; _get_environment(&quot;water(l)&quot;)</span>
<span class="sd">    &#39;water&#39;</span>
<span class="sd">    &gt;&gt;&gt; _get_environment(&quot;water(liquid)&quot;)</span>
<span class="sd">    &#39;water&#39;</span>
<span class="sd">    &gt;&gt;&gt; _get_environment(&quot;dcm(l)&quot;)</span>
<span class="sd">    &#39;dichloromethane&#39;</span>

<span class="sd">    This function also works for names specifying transition states:</span>

<span class="sd">    &gt;&gt;&gt; _get_environment(&quot;A‡(w)&quot;)</span>
<span class="sd">    &#39;water&#39;</span>
<span class="sd">    &gt;&gt;&gt; _get_environment(&quot;TS#(dmf)&quot;)</span>
<span class="sd">    &#39;n,n-dimethylformamide&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">token</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span>
        <span class="sa">r</span><span class="s2">&quot;\s*(?P&lt;compound&gt;[^\s\(\)]+)\s*(?P&lt;environment&gt;\([^\s\(\)]+\))?\s*&quot;</span><span class="p">,</span> <span class="n">name</span>
    <span class="p">)</span><span class="o">.</span><span class="n">groupdict</span><span class="p">(</span><span class="s2">&quot;(gas)&quot;</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">token</span><span class="p">[</span><span class="s2">&quot;compound&quot;</span><span class="p">]</span>

    <span class="n">environment</span> <span class="o">=</span> <span class="n">token</span><span class="p">[</span><span class="s2">&quot;environment&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">environment</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;l&quot;</span><span class="p">,</span> <span class="s2">&quot;liquid&quot;</span><span class="p">}:</span>
        <span class="n">environment</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">if</span> <span class="n">environment</span> <span class="ow">in</span> <span class="n">_abbr_environment</span><span class="p">:</span>
        <span class="n">environment</span> <span class="o">=</span> <span class="n">_abbr_environment</span><span class="p">[</span><span class="n">environment</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">environment</span>


<span class="k">def</span> <span class="nf">is_transition_state</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check whether a name specifies a transition state.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; is_transition_state(&quot;A#&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_transition_state(&quot;A‡&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_transition_state(&quot;pyrrole#&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_transition_state(&quot;pyrrole‡&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_transition_state(&quot;A&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_transition_state(&quot;A~&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_transition_state(&quot;pyrrole&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_transition_state(&quot;pyrrole~&quot;)</span>
<span class="sd">    False</span>

<span class="sd">    This function also works for names that specify environment:</span>

<span class="sd">    &gt;&gt;&gt; is_transition_state(&quot;A#(w)&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_transition_state(&quot;A‡(w)&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_transition_state(&quot;TS#(w)&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_transition_state(&quot;TS‡(w)&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_transition_state(&quot;A(w)&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_transition_state(&quot;A~(w)&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_transition_state(&quot;TS(w)&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_transition_state(&quot;TS~(w)&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">marker</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;‡&quot;</span><span class="p">,</span> <span class="s2">&quot;#&quot;</span><span class="p">}:</span>
        <span class="k">if</span> <span class="n">marker</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">parse_reactions</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Text</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Text</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Scheme</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse a kinetic model as a chemical reaction scheme.</span>

<span class="sd">    This is an essential part of the parsing process.</span>
<span class="sd">    See `overreact.io.parse_model` other details.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    text : str or sequence of str</span>
<span class="sd">        Model description or sequence of lines of it.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    scheme : Scheme</span>
<span class="sd">        A descriptor of the reaction scheme.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The model description should comply with the mini-language for systems of</span>
<span class="sd">    reactions. A semi-formal definition of the grammar in</span>
<span class="sd">    [Backus–Naur form](https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form)</span>
<span class="sd">    is given below:</span>

<span class="sd">             equation ::= equation_side arrow equation_side</span>
<span class="sd">        equation_side ::= coefficient compound [&#39;+&#39; coefficient compound]*</span>
<span class="sd">          coefficient ::= [integers] (defaults to 1)</span>
<span class="sd">             compound ::= mix of printable characters</span>
<span class="sd">                arrow ::= &#39;-&gt;&#39; | &#39;&lt;=&gt;&#39; | &#39;&lt;-&#39;</span>

<span class="sd">    Blank lines and comments (starting with `//`) are ignored. Repeated</span>
<span class="sd">    reactions are ignored. Furthermore, reactions can be chained one after</span>
<span class="sd">    another and, if a single compound (with either a `‡` or a `#` at the end)</span>
<span class="sd">    appears alone on one side of a reaction, it&#39;s considered a transition</span>
<span class="sd">    state. Transition states have zero lifetime during the simulation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    What follows is a rather long tour over the parsing process and its</span>
<span class="sd">    output in general. You can skip it if you are not interested in the</span>
<span class="sd">    details.</span>

<span class="sd">    &gt;&gt;&gt; scheme = parse_reactions(&quot;A -&gt; B  // a direct reaction&quot;)</span>

<span class="sd">    The reaction above is a direct one (observe that comments are ignored). The</span>
<span class="sd">    returned object has the following attributes:</span>

<span class="sd">    &gt;&gt;&gt; scheme.compounds</span>
<span class="sd">    (&#39;A&#39;, &#39;B&#39;)</span>
<span class="sd">    &gt;&gt;&gt; scheme.reactions</span>
<span class="sd">    (&#39;A -&gt; B&#39;,)</span>
<span class="sd">    &gt;&gt;&gt; scheme.is_half_equilibrium</span>
<span class="sd">    (False,)</span>
<span class="sd">    &gt;&gt;&gt; scheme.A</span>
<span class="sd">    ((-1.,), (1.,))</span>
<span class="sd">    &gt;&gt;&gt; scheme.B</span>
<span class="sd">    ((-1.,), (1.,))</span>

<span class="sd">    The same reaction can be specified in reverse order:</span>

<span class="sd">    &gt;&gt;&gt; parse_reactions(&quot;B &lt;- A  // reverse reaction of the above&quot;)</span>
<span class="sd">    Scheme(compounds=(&#39;A&#39;, &#39;B&#39;),</span>
<span class="sd">           reactions=(&#39;A -&gt; B&#39;,),</span>
<span class="sd">           is_half_equilibrium=(False,),</span>
<span class="sd">           A=((-1.,), (1.,)),</span>
<span class="sd">           B=((-1.,), (1.,)))</span>

<span class="sd">    Equilibria produce twice as many direct reactions, while the $B$ matrix</span>
<span class="sd">    defines an energy relationship for only one of each pair:</span>

<span class="sd">    &gt;&gt;&gt; parse_reactions(&quot;A &lt;=&gt; B  // an equilibrium&quot;)</span>
<span class="sd">    Scheme(compounds=(&#39;A&#39;, &#39;B&#39;),</span>
<span class="sd">           reactions=(&#39;A -&gt; B&#39;, &#39;B -&gt; A&#39;),</span>
<span class="sd">           is_half_equilibrium=(True, True),</span>
<span class="sd">           A=((-1.,  1.),</span>
<span class="sd">              (1., -1.)),</span>
<span class="sd">           B=((-1.,  0.),</span>
<span class="sd">              (1.,  0.)))</span>

<span class="sd">    Adding twice the same reaction results in a single reaction being added.</span>
<span class="sd">    This of course also works with equilibria (extra whitespaces are ignored):</span>

<span class="sd">    &gt;&gt;&gt; parse_reactions(&#39;&#39;&#39;</span>
<span class="sd">    ...     A &lt;=&gt; B  -&gt; A</span>
<span class="sd">    ...     A  -&gt; B &lt;=&gt; A</span>
<span class="sd">    ...     A  -&gt; B &lt;-  A</span>
<span class="sd">    ...     B &lt;-  A  -&gt; B</span>
<span class="sd">    ... &#39;&#39;&#39;)</span>
<span class="sd">    Scheme(compounds=(&#39;A&#39;, &#39;B&#39;),</span>
<span class="sd">           reactions=(&#39;A -&gt; B&#39;, &#39;B -&gt; A&#39;),</span>
<span class="sd">           is_half_equilibrium=(True, True),</span>
<span class="sd">           A=((-1.,  1.),</span>
<span class="sd">              (1., -1.)),</span>
<span class="sd">           B=((-1.,  0.),</span>
<span class="sd">              (1.,  0.)))</span>

<span class="sd">    Transition states are specified with a special symbol at the end (either</span>
<span class="sd">    `‡` or `#`). They are shown among compounds, but the matrix $A$ ensures</span>
<span class="sd">    they&#39;ll never have a non-zero rate of formation/consumption. On the other</span>
<span class="sd">    hand, they are needed in the $B$ matrix:</span>

<span class="sd">    &gt;&gt;&gt; parse_reactions(&quot;A -&gt; A‡ -&gt; B&quot;)</span>
<span class="sd">    Scheme(compounds=(&#39;A&#39;, &#39;A‡&#39;, &#39;B&#39;),</span>
<span class="sd">           reactions=(&#39;A -&gt; B&#39;,),</span>
<span class="sd">           is_half_equilibrium=(False,),</span>
<span class="sd">           A=((-1.,), (0.,), (1.,)),</span>
<span class="sd">           B=((-1.,), (1.,), (0.,)))</span>

<span class="sd">    This gives the same result as above:</span>

<span class="sd">    &gt;&gt;&gt; parse_reactions(&quot;A -&gt; A‡ -&gt; B &lt;- A‡ &lt;- A&quot;)</span>
<span class="sd">    Scheme(compounds=(&#39;A&#39;, &#39;A‡&#39;, &#39;B&#39;),</span>
<span class="sd">           reactions=(&#39;A -&gt; B&#39;,),</span>
<span class="sd">           is_half_equilibrium=(False,),</span>
<span class="sd">           A=((-1.,), (0.,), (1.,)),</span>
<span class="sd">           B=((-1.,), (1.,), (0.,)))</span>

<span class="sd">    It is possible to define a reaction whose product is the same as the</span>
<span class="sd">    reactant. This is found in isomerization processes (e.g., ammonia</span>
<span class="sd">    inversion or the methyl rotation in ethane):</span>

<span class="sd">    &gt;&gt;&gt; parse_reactions(&quot;S -&gt; E‡ -&gt; S&quot;)</span>
<span class="sd">    Scheme(compounds=(&#39;S&#39;, &#39;E‡&#39;),</span>
<span class="sd">           reactions=(&#39;S -&gt; S&#39;,),</span>
<span class="sd">           is_half_equilibrium=(False,),</span>
<span class="sd">           A=((0.,), (0.,)),</span>
<span class="sd">           B=((-1.,), (1.,)))</span>

<span class="sd">    As such, a column full of zeros in the $A$ matrix corresponds to a reaction</span>
<span class="sd">    with zero net change. As can be seen, overreact allows for very general</span>
<span class="sd">    models. An interesting feature is that a single transition state can link</span>
<span class="sd">    many different compounds (whether it is useful is a matter of debate):</span>

<span class="sd">    &gt;&gt;&gt; parse_reactions(&#39;&#39;&#39;</span>
<span class="sd">    ...     B  -&gt; B‡  -&gt; C  // chained reactions and transition states</span>
<span class="sd">    ...     B‡ -&gt; D         // this is a bifurcation</span>
<span class="sd">    ...     B  -&gt; B&#39;‡ -&gt; E  // this is a classical competitive reaction</span>
<span class="sd">    ...     A  -&gt; B‡</span>
<span class="sd">    ... &#39;&#39;&#39;)</span>
<span class="sd">    Scheme(compounds=(&#39;B&#39;, &#39;B‡&#39;, &#39;C&#39;, &#39;D&#39;, &quot;B&#39;‡&quot;, &#39;E&#39;, &#39;A&#39;),</span>
<span class="sd">           reactions=(&#39;B -&gt; C&#39;, &#39;B -&gt; D&#39;, &#39;B -&gt; E&#39;, &#39;A -&gt; C&#39;, &#39;A -&gt; D&#39;),</span>
<span class="sd">           is_half_equilibrium=(False, False, False, False, False),</span>
<span class="sd">           A=((-1., -1., -1.,  0.,  0.),</span>
<span class="sd">              (0.,  0.,  0.,  0.,  0.),</span>
<span class="sd">              (1.,  0.,  0.,  1.,  0.),</span>
<span class="sd">              (0.,  1.,  0.,  0.,  1.),</span>
<span class="sd">              (0.,  0.,  0.,  0.,  0.),</span>
<span class="sd">              (0.,  0.,  1.,  0.,  0.),</span>
<span class="sd">              (0.,  0.,  0., -1., -1.)),</span>
<span class="sd">           B=((-1., -1., -1.,  0.,  0.),</span>
<span class="sd">              (1.,  1.,  0.,  1.,  1.),</span>
<span class="sd">              (0.,  0.,  0.,  0.,  0.),</span>
<span class="sd">              (0.,  0.,  0.,  0.,  0.),</span>
<span class="sd">              (0.,  0.,  1.,  0.,  0.),</span>
<span class="sd">              (0.,  0.,  0.,  0.,  0.),</span>
<span class="sd">              (0.,  0.,  0., -1., -1.)))</span>

<span class="sd">    The following is a borderline case but both reactions should be considered</span>
<span class="sd">    different since they define different processes:</span>

<span class="sd">    &gt;&gt;&gt; parse_reactions(&#39;&#39;&#39;</span>
<span class="sd">    ...     A -&gt; A‡ -&gt; B</span>
<span class="sd">    ...     A -&gt; B</span>
<span class="sd">    ... &#39;&#39;&#39;)</span>
<span class="sd">    Scheme(compounds=(&#39;A&#39;, &#39;A‡&#39;, &#39;B&#39;),</span>
<span class="sd">           reactions=(&#39;A -&gt; B&#39;, &#39;A -&gt; B&#39;),</span>
<span class="sd">           is_half_equilibrium=(False, False),</span>
<span class="sd">           A=((-1., -1.),</span>
<span class="sd">              (0.,  0.),</span>
<span class="sd">              (1.,  1.)),</span>
<span class="sd">           B=((-1., -1.),</span>
<span class="sd">              (1.,  0.),</span>
<span class="sd">              (0.,  1.)))</span>

<span class="sd">    The following is correct behavior. In fact, the reactions are badly</span>
<span class="sd">    defined: if more than one transition state are chained, the following</span>
<span class="sd">    happens, which is correct since it&#39;s the most physically plausible model</span>
<span class="sd">    that can be extracted. It can be seen as a feature that the product B is</span>
<span class="sd">    ignored and not the reactant A, since the user would easily see the mistake</span>
<span class="sd">    in graphs of concentration over time (the alternative would be no</span>
<span class="sd">    reaction happening at all, which is rather cryptic to debug).</span>

<span class="sd">    &gt;&gt;&gt; parse_reactions(&quot;A -&gt; A‡ -&gt; A&#39;‡ -&gt; B&quot;)</span>
<span class="sd">    Scheme(compounds=(&#39;A&#39;, &#39;A‡&#39;, &quot;A&#39;‡&quot;, &#39;B&#39;),</span>
<span class="sd">           reactions=(&quot;A -&gt; A&#39;‡&quot;,),</span>
<span class="sd">           is_half_equilibrium=(False,),</span>
<span class="sd">           A=((-1.,), (0.,), (1.,), (0.,)),</span>
<span class="sd">           B=((-1.,), (1.,), (0.,), (0.,)))</span>

<span class="sd">    In any case, it&#39;s not clear how a reaction barrier be defined in such a</span>
<span class="sd">    case. If you have a use case, don&#39;t hesitate to</span>
<span class="sd">    [open an issue](https://github.com/geem-lab/overreact/issues/), we&#39;ll be</span>
<span class="sd">    happy to hear from you.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">compounds</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Text</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">reactions</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span>
        <span class="nb">tuple</span><span class="p">[</span><span class="n">Text</span><span class="p">,</span> <span class="n">Text</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">Text</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Text</span><span class="p">],</span> <span class="o">...</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">A</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>  <span class="c1"># coefficients between reactants and products</span>
    <span class="n">B</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>  <span class="c1"># coefficients between reactants and transition states</span>

    <span class="k">def</span> <span class="nf">_add_reaction</span><span class="p">(</span><span class="n">reactants</span><span class="p">,</span> <span class="n">products</span><span class="p">,</span> <span class="n">is_half_equilibrium</span><span class="p">,</span> <span class="n">transition</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Local helper function with side-effects.&quot;&quot;&quot;</span>
        <span class="c1"># TODO(schneiderfelipe): what if reaction is defined, then redefined</span>
        <span class="c1"># as equilibrium, or vice-versa?</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">transition</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="p">(</span><span class="n">reactants</span><span class="p">,</span> <span class="n">products</span><span class="p">,</span> <span class="n">is_half_equilibrium</span><span class="p">,</span> <span class="n">transition</span><span class="p">)</span> <span class="ow">in</span> <span class="n">reactions</span>
        <span class="p">):</span>
            <span class="k">return</span>

        <span class="c1"># found new reaction</span>
        <span class="n">reactions</span><span class="p">[(</span><span class="n">reactants</span><span class="p">,</span> <span class="n">products</span><span class="p">,</span> <span class="n">is_half_equilibrium</span><span class="p">,</span> <span class="n">transition</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">A_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">compounds</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">coefficient</span><span class="p">,</span> <span class="n">reactant</span> <span class="ow">in</span> <span class="n">reactants</span><span class="p">:</span>
            <span class="n">A_vector</span><span class="p">[</span><span class="n">compounds</span><span class="p">[</span><span class="n">reactant</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="n">coefficient</span>
        <span class="n">B_vector</span> <span class="o">=</span> <span class="n">A_vector</span>

        <span class="k">if</span> <span class="n">transition</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">B_vector</span> <span class="o">=</span> <span class="n">A_vector</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># it&#39;s assumed that</span>
            <span class="c1">#   1. there&#39;s a singe transition compound, and</span>
            <span class="c1">#   2. its coefficient equals one</span>
            <span class="n">B_vector</span><span class="p">[</span><span class="n">compounds</span><span class="p">[</span><span class="n">transition</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]]]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">coefficient</span><span class="p">,</span> <span class="n">product</span> <span class="ow">in</span> <span class="n">products</span><span class="p">:</span>
            <span class="n">A_vector</span><span class="p">[</span><span class="n">compounds</span><span class="p">[</span><span class="n">product</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">coefficient</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">is_half_equilibrium</span>
            <span class="ow">and</span> <span class="p">(</span><span class="n">products</span><span class="p">,</span> <span class="n">reactants</span><span class="p">,</span> <span class="n">is_half_equilibrium</span><span class="p">,</span> <span class="n">transition</span><span class="p">)</span> <span class="ow">in</span> <span class="n">reactions</span>
        <span class="p">):</span>
            <span class="n">B_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">compounds</span><span class="p">))</span>

        <span class="n">A</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A_vector</span><span class="p">)</span>
        <span class="n">B</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">B_vector</span><span class="p">)</span>

    <span class="n">after_transitions</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span>
        <span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Text</span><span class="p">],</span> <span class="o">...</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Text</span><span class="p">]]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">before_transitions</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span>
        <span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Text</span><span class="p">],</span> <span class="o">...</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Text</span><span class="p">]]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">reactants</span><span class="p">,</span> <span class="n">products</span><span class="p">,</span> <span class="n">is_half_equilibrium</span> <span class="ow">in</span> <span class="n">_parse_reactions</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">reactants</span><span class="p">,</span> <span class="n">products</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">in</span> <span class="n">reactions</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="n">reactants</span><span class="p">,</span>
            <span class="n">products</span><span class="p">,</span>
            <span class="kc">True</span><span class="p">,</span>
            <span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span> <span class="ow">in</span> <span class="n">reactions</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">compound</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">reactants</span><span class="p">,</span> <span class="n">products</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">compound</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">compounds</span><span class="p">:</span>
                <span class="c1"># found new compound</span>
                <span class="n">compounds</span><span class="p">[</span><span class="n">compound</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">compounds</span><span class="p">)</span>

        <span class="c1"># TODO(schneiderfelipe): what if a transition state is used in an</span>
        <span class="c1"># equilibrium?</span>

        <span class="c1"># it&#39;s assumed that if a transition shows up,</span>
        <span class="c1">#   1. it&#39;s the only compound in its side of the reaction, and</span>
        <span class="c1">#   2. its coefficient equals one</span>
        <span class="k">if</span> <span class="n">is_transition_state</span><span class="p">(</span><span class="n">reactants</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">before_reactants</span> <span class="ow">in</span> <span class="n">before_transitions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">reactants</span><span class="p">,</span> <span class="p">[]):</span>
                <span class="n">_add_reaction</span><span class="p">(</span>
                    <span class="n">before_reactants</span><span class="p">,</span> <span class="n">products</span><span class="p">,</span> <span class="n">is_half_equilibrium</span><span class="p">,</span> <span class="n">reactants</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">reactants</span> <span class="ow">in</span> <span class="n">after_transitions</span><span class="p">:</span>
                <span class="n">after_transitions</span><span class="p">[</span><span class="n">reactants</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">products</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">after_transitions</span><span class="p">[</span><span class="n">reactants</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">products</span><span class="p">]</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">is_transition_state</span><span class="p">(</span><span class="n">products</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">after_products</span> <span class="ow">in</span> <span class="n">after_transitions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">products</span><span class="p">,</span> <span class="p">[]):</span>
                <span class="n">_add_reaction</span><span class="p">(</span><span class="n">reactants</span><span class="p">,</span> <span class="n">after_products</span><span class="p">,</span> <span class="n">is_half_equilibrium</span><span class="p">,</span> <span class="n">products</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">products</span> <span class="ow">in</span> <span class="n">before_transitions</span><span class="p">:</span>
                <span class="n">before_transitions</span><span class="p">[</span><span class="n">products</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reactants</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">before_transitions</span><span class="p">[</span><span class="n">products</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">reactants</span><span class="p">]</span>
            <span class="k">continue</span>

        <span class="n">_add_reaction</span><span class="p">(</span><span class="n">reactants</span><span class="p">,</span> <span class="n">products</span><span class="p">,</span> <span class="n">is_half_equilibrium</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Scheme</span><span class="p">(</span>
        <span class="n">compounds</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">compounds</span><span class="p">),</span>
        <span class="n">reactions</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">_unparse_reactions</span><span class="p">(</span><span class="n">reactions</span><span class="p">)),</span>
        <span class="n">is_half_equilibrium</span><span class="o">=</span><span class="n">rx</span><span class="o">.</span><span class="n">_misc</span><span class="o">.</span><span class="n">totuple</span><span class="p">([</span><span class="n">reaction</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">reaction</span> <span class="ow">in</span> <span class="n">reactions</span><span class="p">]),</span>
        <span class="n">A</span><span class="o">=</span><span class="n">rx</span><span class="o">.</span><span class="n">_misc</span><span class="o">.</span><span class="n">totuple</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">(</span>
                <span class="p">[[</span><span class="n">vector</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">compounds</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">vector</span><span class="p">))]</span> <span class="k">for</span> <span class="n">vector</span> <span class="ow">in</span> <span class="n">A</span><span class="p">]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="p">),</span>
        <span class="n">B</span><span class="o">=</span><span class="n">rx</span><span class="o">.</span><span class="n">_misc</span><span class="o">.</span><span class="n">totuple</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">(</span>
                <span class="p">[[</span><span class="n">vector</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">compounds</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">vector</span><span class="p">))]</span> <span class="k">for</span> <span class="n">vector</span> <span class="ow">in</span> <span class="n">B</span><span class="p">]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="p">),</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">_parse_reactions</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Parse reactions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    text : str or sequence of str</span>
<span class="sd">        Model description or sequence of lines of it.</span>

<span class="sd">    Yields</span>
<span class="sd">    ------</span>
<span class="sd">    reactants, products : sequence of tuple</span>
<span class="sd">    is_half_equilibrium : bool</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; r = &quot;E + S &lt;=&gt; ES -&gt; ES‡ -&gt; E + P&quot;</span>
<span class="sd">    &gt;&gt;&gt; for reactants, products, is_half_equilibrium in _parse_reactions(r):</span>
<span class="sd">    ...     print(reactants, products, is_half_equilibrium)</span>
<span class="sd">    ((1, &#39;E&#39;), (1, &#39;S&#39;)) ((1, &#39;ES&#39;),) True</span>
<span class="sd">    ((1, &#39;ES&#39;),) ((1, &#39;E&#39;), (1, &#39;S&#39;)) True</span>
<span class="sd">    ((1, &#39;ES&#39;),) ((1, &#39;ES‡&#39;),) False</span>
<span class="sd">    ((1, &#39;ES‡&#39;),) ((1, &#39;E&#39;), (1, &#39;P&#39;)) False</span>

<span class="sd">    `_parse_reactions` and `_unparse_reactions` are, in some sense, inverses of</span>
<span class="sd">    each other:</span>

<span class="sd">    &gt;&gt;&gt; print(&#39;\n&#39;.join(_unparse_reactions(_parse_reactions(&#39;&#39;&#39;</span>
<span class="sd">    ...     1 A -&gt; 2 B &lt;- C &lt;=&gt; 40 D &lt;- E</span>
<span class="sd">    ...     A -&gt; 2 B &lt;=&gt; C</span>
<span class="sd">    ... &#39;&#39;&#39;))))</span>
<span class="sd">    A -&gt; 2 B</span>
<span class="sd">    C -&gt; 2 B</span>
<span class="sd">    C -&gt; 40 D</span>
<span class="sd">    40 D -&gt; C</span>
<span class="sd">    E -&gt; 40 D</span>
<span class="sd">    A -&gt; 2 B</span>
<span class="sd">    2 B -&gt; C</span>
<span class="sd">    C -&gt; 2 B</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">text</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;//&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">pieces</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\s*(-&gt;|&lt;=&gt;|&lt;-)\s*&quot;</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">reactants</span><span class="p">,</span> <span class="n">arrow</span><span class="p">,</span> <span class="n">products</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="n">pieces</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">pieces</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">pieces</span><span class="p">[</span><span class="mi">2</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">arrow</span> <span class="o">==</span> <span class="s2">&quot;&lt;-&quot;</span><span class="p">:</span>
                <span class="n">reactants</span><span class="p">,</span> <span class="n">products</span><span class="p">,</span> <span class="n">arrow</span> <span class="o">=</span> <span class="n">products</span><span class="p">,</span> <span class="n">reactants</span><span class="p">,</span> <span class="s2">&quot;-&gt;&quot;</span>
            <span class="n">reactants</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_parse_side</span><span class="p">(</span><span class="n">reactants</span><span class="p">))</span>
            <span class="n">products</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_parse_side</span><span class="p">(</span><span class="n">products</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">arrow</span> <span class="o">==</span> <span class="s2">&quot;&lt;=&gt;&quot;</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">reactants</span><span class="p">,</span> <span class="n">products</span><span class="p">,</span> <span class="kc">True</span>
                <span class="k">yield</span> <span class="n">products</span><span class="p">,</span> <span class="n">reactants</span><span class="p">,</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">reactants</span><span class="p">,</span> <span class="n">products</span><span class="p">,</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">_unparse_reactions</span><span class="p">(</span><span class="n">reactions</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return string representations of reactions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    reactions : sequence of tuple</span>

<span class="sd">    Yields</span>
<span class="sd">    ------</span>
<span class="sd">    text : str</span>
<span class="sd">        Line of model description.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; for text in _unparse_reactions([(((1, &#39;E&#39;), (1, &#39;S&#39;)), ((1, &#39;ES&#39;),),</span>
<span class="sd">    ...         True),</span>
<span class="sd">    ...     (((1, &#39;ES&#39;),), ((1, &#39;E&#39;), (1, &#39;S&#39;)), True),</span>
<span class="sd">    ...     (((1, &#39;ES&#39;),), ((1, &#39;ES‡&#39;),), False),</span>
<span class="sd">    ...     (((1, &#39;ES‡&#39;),), ((1, &#39;E&#39;), (1, &#39;P&#39;)), False)]):</span>
<span class="sd">    ...     print(text)</span>
<span class="sd">    E + S -&gt; ES</span>
<span class="sd">    ES -&gt; E + S</span>
<span class="sd">    ES -&gt; ES‡</span>
<span class="sd">    ES‡ -&gt; E + P</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">reaction</span> <span class="ow">in</span> <span class="n">reactions</span><span class="p">:</span>
        <span class="k">yield</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">_unparse_side</span><span class="p">(</span><span class="n">reaction</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">_unparse_side</span><span class="p">(</span><span class="n">reaction</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span>


<span class="k">def</span> <span class="nf">_parse_side</span><span class="p">(</span><span class="n">side</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parse a left or right hand side of a reaction.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    side : str</span>

<span class="sd">    Yields</span>
<span class="sd">    ------</span>
<span class="sd">    coefficient : int</span>
<span class="sd">    compound : str</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; for coefficient, compound in _parse_side(&quot;A + B + 2 C + 500 D&quot;):</span>
<span class="sd">    ...     print(coefficient, compound)</span>
<span class="sd">      1 A</span>
<span class="sd">      1 B</span>
<span class="sd">      2 C</span>
<span class="sd">    500 D</span>

<span class="sd">    `_parse_side` and `_unparse_side` are, in some sense, inverses of each</span>
<span class="sd">    other:</span>

<span class="sd">    &gt;&gt;&gt; _unparse_side(_parse_side(&quot;   2     *A*1*    +  40B1  +  chlorophyll&quot;))</span>
<span class="sd">    &#39;2 *A*1* + 40 B1 + chlorophyll&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\s+\+\s+&quot;</span><span class="p">,</span> <span class="n">side</span><span class="p">):</span>
        <span class="n">token</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span>
            <span class="sa">r</span><span class="s2">&quot;\s*(?P&lt;coefficient&gt;\d+)?\s*(?P&lt;compound&gt;[^\s]+)\s*&quot;</span><span class="p">,</span> <span class="n">token</span>
        <span class="p">)</span><span class="o">.</span><span class="n">groupdict</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">yield</span> <span class="nb">int</span><span class="p">(</span><span class="n">token</span><span class="p">[</span><span class="s2">&quot;coefficient&quot;</span><span class="p">]),</span> <span class="n">token</span><span class="p">[</span><span class="s2">&quot;compound&quot;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_unparse_side</span><span class="p">(</span><span class="n">unside</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return string representation of a left/right hand side of a reaction.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    unside : sequence of tuple</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    side : str</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; _unparse_side([(1, &#39;A&#39;),</span>
<span class="sd">    ...     (1, &#39;B&#39;),</span>
<span class="sd">    ...     (2, &#39;C&#39;),</span>
<span class="sd">    ...     (500, &#39;D&#39;)])</span>
<span class="sd">    &#39;A + B + 2 C + 500 D&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s2">&quot; + &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">compound</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">coefficient</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">coefficient</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">compound</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">for</span> <span class="n">coefficient</span><span class="p">,</span> <span class="n">compound</span> <span class="ow">in</span> <span class="n">unside</span>
    <span class="p">)</span>
</pre></div>

        </details>

            </section>
                <section id="Scheme">
                                <div class="attr class">
        <a class="headerlink" href="#Scheme">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">Scheme</span><wbr>(<span class="base">typing.NamedTuple</span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Scheme</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A descriptor of a chemical reaction network.</span>

<span class="sd">    Mostly likely, this comes from a parsed input file.</span>
<span class="sd">    See `overreact.io.parse_model`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">compounds</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Text</span><span class="p">]</span>
    <span class="sd">&quot;&quot;&quot;A descriptor of compounds.&quot;&quot;&quot;</span>
    <span class="n">reactions</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Text</span><span class="p">]</span>
    <span class="sd">&quot;&quot;&quot;A descriptor of reactions.&quot;&quot;&quot;</span>
    <span class="n">is_half_equilibrium</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span>
    <span class="sd">&quot;&quot;&quot;An indicator of whether a reaction is half-equilibrium.&quot;&quot;&quot;</span>
    <span class="n">A</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="sd">&quot;&quot;&quot;A matrix of stoichiometric coefficients between reactants and products.&quot;&quot;&quot;</span>
    <span class="n">B</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="sd">&quot;&quot;&quot;A matrix of stoichiometric coefficients between reactants and transition states.&quot;&quot;&quot;</span>
</pre></div>

        </details>

            <div class="docstring"><p>A descriptor of a chemical reaction network.</p>

<p>Mostly likely, this comes from a parsed input file.
See <code><a href="io.html#parse_model">overreact.io.parse_model</a></code>.</p>
</div>


                            <div id="Scheme.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Scheme.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">Scheme</span><span class="signature">(
    compounds: Sequence[str],
    reactions: Sequence[str],
    is_half_equilibrium: Sequence[bool],
    A: numpy.ndarray,
    B: numpy.ndarray
)</span>
    </div>

        
            <div class="docstring"><p>Create new instance of Scheme(compounds, reactions, is_half_equilibrium, A, B)</p>
</div>


                            </div>
                            <div id="Scheme.compounds" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Scheme.compounds">#&nbsp;&nbsp</a>

        <span class="name">compounds</span><span class="annotation">: Sequence[str]</span>
    </div>

            <div class="docstring"><p>A descriptor of compounds.</p>
</div>


                            </div>
                            <div id="Scheme.reactions" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Scheme.reactions">#&nbsp;&nbsp</a>

        <span class="name">reactions</span><span class="annotation">: Sequence[str]</span>
    </div>

            <div class="docstring"><p>A descriptor of reactions.</p>
</div>


                            </div>
                            <div id="Scheme.is_half_equilibrium" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Scheme.is_half_equilibrium">#&nbsp;&nbsp</a>

        <span class="name">is_half_equilibrium</span><span class="annotation">: Sequence[bool]</span>
    </div>

            <div class="docstring"><p>An indicator of whether a reaction is half-equilibrium.</p>
</div>


                            </div>
                            <div id="Scheme.A" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Scheme.A">#&nbsp;&nbsp</a>

        <span class="name">A</span><span class="annotation">: numpy.ndarray</span>
    </div>

            <div class="docstring"><p>A matrix of stoichiometric coefficients between reactants and products.</p>
</div>


                            </div>
                            <div id="Scheme.B" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Scheme.B">#&nbsp;&nbsp</a>

        <span class="name">B</span><span class="annotation">: numpy.ndarray</span>
    </div>

            <div class="docstring"><p>A matrix of stoichiometric coefficients between reactants and transition states.</p>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt>builtins.tuple</dt>
                                <dd id="Scheme.index" class="function">index</dd>
                <dd id="Scheme.count" class="function">count</dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="parse_reactions">
                            <div class="attr function"><a class="headerlink" href="#parse_reactions">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">parse_reactions</span><span class="signature">(text: Union[str, Sequence[str]]) -&gt; <a href="#Scheme">overreact.core.Scheme</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">parse_reactions</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Text</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Text</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Scheme</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse a kinetic model as a chemical reaction scheme.</span>

<span class="sd">    This is an essential part of the parsing process.</span>
<span class="sd">    See `overreact.io.parse_model` other details.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    text : str or sequence of str</span>
<span class="sd">        Model description or sequence of lines of it.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    scheme : Scheme</span>
<span class="sd">        A descriptor of the reaction scheme.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The model description should comply with the mini-language for systems of</span>
<span class="sd">    reactions. A semi-formal definition of the grammar in</span>
<span class="sd">    [Backus–Naur form](https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form)</span>
<span class="sd">    is given below:</span>

<span class="sd">             equation ::= equation_side arrow equation_side</span>
<span class="sd">        equation_side ::= coefficient compound [&#39;+&#39; coefficient compound]*</span>
<span class="sd">          coefficient ::= [integers] (defaults to 1)</span>
<span class="sd">             compound ::= mix of printable characters</span>
<span class="sd">                arrow ::= &#39;-&gt;&#39; | &#39;&lt;=&gt;&#39; | &#39;&lt;-&#39;</span>

<span class="sd">    Blank lines and comments (starting with `//`) are ignored. Repeated</span>
<span class="sd">    reactions are ignored. Furthermore, reactions can be chained one after</span>
<span class="sd">    another and, if a single compound (with either a `‡` or a `#` at the end)</span>
<span class="sd">    appears alone on one side of a reaction, it&#39;s considered a transition</span>
<span class="sd">    state. Transition states have zero lifetime during the simulation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    What follows is a rather long tour over the parsing process and its</span>
<span class="sd">    output in general. You can skip it if you are not interested in the</span>
<span class="sd">    details.</span>

<span class="sd">    &gt;&gt;&gt; scheme = parse_reactions(&quot;A -&gt; B  // a direct reaction&quot;)</span>

<span class="sd">    The reaction above is a direct one (observe that comments are ignored). The</span>
<span class="sd">    returned object has the following attributes:</span>

<span class="sd">    &gt;&gt;&gt; scheme.compounds</span>
<span class="sd">    (&#39;A&#39;, &#39;B&#39;)</span>
<span class="sd">    &gt;&gt;&gt; scheme.reactions</span>
<span class="sd">    (&#39;A -&gt; B&#39;,)</span>
<span class="sd">    &gt;&gt;&gt; scheme.is_half_equilibrium</span>
<span class="sd">    (False,)</span>
<span class="sd">    &gt;&gt;&gt; scheme.A</span>
<span class="sd">    ((-1.,), (1.,))</span>
<span class="sd">    &gt;&gt;&gt; scheme.B</span>
<span class="sd">    ((-1.,), (1.,))</span>

<span class="sd">    The same reaction can be specified in reverse order:</span>

<span class="sd">    &gt;&gt;&gt; parse_reactions(&quot;B &lt;- A  // reverse reaction of the above&quot;)</span>
<span class="sd">    Scheme(compounds=(&#39;A&#39;, &#39;B&#39;),</span>
<span class="sd">           reactions=(&#39;A -&gt; B&#39;,),</span>
<span class="sd">           is_half_equilibrium=(False,),</span>
<span class="sd">           A=((-1.,), (1.,)),</span>
<span class="sd">           B=((-1.,), (1.,)))</span>

<span class="sd">    Equilibria produce twice as many direct reactions, while the $B$ matrix</span>
<span class="sd">    defines an energy relationship for only one of each pair:</span>

<span class="sd">    &gt;&gt;&gt; parse_reactions(&quot;A &lt;=&gt; B  // an equilibrium&quot;)</span>
<span class="sd">    Scheme(compounds=(&#39;A&#39;, &#39;B&#39;),</span>
<span class="sd">           reactions=(&#39;A -&gt; B&#39;, &#39;B -&gt; A&#39;),</span>
<span class="sd">           is_half_equilibrium=(True, True),</span>
<span class="sd">           A=((-1.,  1.),</span>
<span class="sd">              (1., -1.)),</span>
<span class="sd">           B=((-1.,  0.),</span>
<span class="sd">              (1.,  0.)))</span>

<span class="sd">    Adding twice the same reaction results in a single reaction being added.</span>
<span class="sd">    This of course also works with equilibria (extra whitespaces are ignored):</span>

<span class="sd">    &gt;&gt;&gt; parse_reactions(&#39;&#39;&#39;</span>
<span class="sd">    ...     A &lt;=&gt; B  -&gt; A</span>
<span class="sd">    ...     A  -&gt; B &lt;=&gt; A</span>
<span class="sd">    ...     A  -&gt; B &lt;-  A</span>
<span class="sd">    ...     B &lt;-  A  -&gt; B</span>
<span class="sd">    ... &#39;&#39;&#39;)</span>
<span class="sd">    Scheme(compounds=(&#39;A&#39;, &#39;B&#39;),</span>
<span class="sd">           reactions=(&#39;A -&gt; B&#39;, &#39;B -&gt; A&#39;),</span>
<span class="sd">           is_half_equilibrium=(True, True),</span>
<span class="sd">           A=((-1.,  1.),</span>
<span class="sd">              (1., -1.)),</span>
<span class="sd">           B=((-1.,  0.),</span>
<span class="sd">              (1.,  0.)))</span>

<span class="sd">    Transition states are specified with a special symbol at the end (either</span>
<span class="sd">    `‡` or `#`). They are shown among compounds, but the matrix $A$ ensures</span>
<span class="sd">    they&#39;ll never have a non-zero rate of formation/consumption. On the other</span>
<span class="sd">    hand, they are needed in the $B$ matrix:</span>

<span class="sd">    &gt;&gt;&gt; parse_reactions(&quot;A -&gt; A‡ -&gt; B&quot;)</span>
<span class="sd">    Scheme(compounds=(&#39;A&#39;, &#39;A‡&#39;, &#39;B&#39;),</span>
<span class="sd">           reactions=(&#39;A -&gt; B&#39;,),</span>
<span class="sd">           is_half_equilibrium=(False,),</span>
<span class="sd">           A=((-1.,), (0.,), (1.,)),</span>
<span class="sd">           B=((-1.,), (1.,), (0.,)))</span>

<span class="sd">    This gives the same result as above:</span>

<span class="sd">    &gt;&gt;&gt; parse_reactions(&quot;A -&gt; A‡ -&gt; B &lt;- A‡ &lt;- A&quot;)</span>
<span class="sd">    Scheme(compounds=(&#39;A&#39;, &#39;A‡&#39;, &#39;B&#39;),</span>
<span class="sd">           reactions=(&#39;A -&gt; B&#39;,),</span>
<span class="sd">           is_half_equilibrium=(False,),</span>
<span class="sd">           A=((-1.,), (0.,), (1.,)),</span>
<span class="sd">           B=((-1.,), (1.,), (0.,)))</span>

<span class="sd">    It is possible to define a reaction whose product is the same as the</span>
<span class="sd">    reactant. This is found in isomerization processes (e.g., ammonia</span>
<span class="sd">    inversion or the methyl rotation in ethane):</span>

<span class="sd">    &gt;&gt;&gt; parse_reactions(&quot;S -&gt; E‡ -&gt; S&quot;)</span>
<span class="sd">    Scheme(compounds=(&#39;S&#39;, &#39;E‡&#39;),</span>
<span class="sd">           reactions=(&#39;S -&gt; S&#39;,),</span>
<span class="sd">           is_half_equilibrium=(False,),</span>
<span class="sd">           A=((0.,), (0.,)),</span>
<span class="sd">           B=((-1.,), (1.,)))</span>

<span class="sd">    As such, a column full of zeros in the $A$ matrix corresponds to a reaction</span>
<span class="sd">    with zero net change. As can be seen, overreact allows for very general</span>
<span class="sd">    models. An interesting feature is that a single transition state can link</span>
<span class="sd">    many different compounds (whether it is useful is a matter of debate):</span>

<span class="sd">    &gt;&gt;&gt; parse_reactions(&#39;&#39;&#39;</span>
<span class="sd">    ...     B  -&gt; B‡  -&gt; C  // chained reactions and transition states</span>
<span class="sd">    ...     B‡ -&gt; D         // this is a bifurcation</span>
<span class="sd">    ...     B  -&gt; B&#39;‡ -&gt; E  // this is a classical competitive reaction</span>
<span class="sd">    ...     A  -&gt; B‡</span>
<span class="sd">    ... &#39;&#39;&#39;)</span>
<span class="sd">    Scheme(compounds=(&#39;B&#39;, &#39;B‡&#39;, &#39;C&#39;, &#39;D&#39;, &quot;B&#39;‡&quot;, &#39;E&#39;, &#39;A&#39;),</span>
<span class="sd">           reactions=(&#39;B -&gt; C&#39;, &#39;B -&gt; D&#39;, &#39;B -&gt; E&#39;, &#39;A -&gt; C&#39;, &#39;A -&gt; D&#39;),</span>
<span class="sd">           is_half_equilibrium=(False, False, False, False, False),</span>
<span class="sd">           A=((-1., -1., -1.,  0.,  0.),</span>
<span class="sd">              (0.,  0.,  0.,  0.,  0.),</span>
<span class="sd">              (1.,  0.,  0.,  1.,  0.),</span>
<span class="sd">              (0.,  1.,  0.,  0.,  1.),</span>
<span class="sd">              (0.,  0.,  0.,  0.,  0.),</span>
<span class="sd">              (0.,  0.,  1.,  0.,  0.),</span>
<span class="sd">              (0.,  0.,  0., -1., -1.)),</span>
<span class="sd">           B=((-1., -1., -1.,  0.,  0.),</span>
<span class="sd">              (1.,  1.,  0.,  1.,  1.),</span>
<span class="sd">              (0.,  0.,  0.,  0.,  0.),</span>
<span class="sd">              (0.,  0.,  0.,  0.,  0.),</span>
<span class="sd">              (0.,  0.,  1.,  0.,  0.),</span>
<span class="sd">              (0.,  0.,  0.,  0.,  0.),</span>
<span class="sd">              (0.,  0.,  0., -1., -1.)))</span>

<span class="sd">    The following is a borderline case but both reactions should be considered</span>
<span class="sd">    different since they define different processes:</span>

<span class="sd">    &gt;&gt;&gt; parse_reactions(&#39;&#39;&#39;</span>
<span class="sd">    ...     A -&gt; A‡ -&gt; B</span>
<span class="sd">    ...     A -&gt; B</span>
<span class="sd">    ... &#39;&#39;&#39;)</span>
<span class="sd">    Scheme(compounds=(&#39;A&#39;, &#39;A‡&#39;, &#39;B&#39;),</span>
<span class="sd">           reactions=(&#39;A -&gt; B&#39;, &#39;A -&gt; B&#39;),</span>
<span class="sd">           is_half_equilibrium=(False, False),</span>
<span class="sd">           A=((-1., -1.),</span>
<span class="sd">              (0.,  0.),</span>
<span class="sd">              (1.,  1.)),</span>
<span class="sd">           B=((-1., -1.),</span>
<span class="sd">              (1.,  0.),</span>
<span class="sd">              (0.,  1.)))</span>

<span class="sd">    The following is correct behavior. In fact, the reactions are badly</span>
<span class="sd">    defined: if more than one transition state are chained, the following</span>
<span class="sd">    happens, which is correct since it&#39;s the most physically plausible model</span>
<span class="sd">    that can be extracted. It can be seen as a feature that the product B is</span>
<span class="sd">    ignored and not the reactant A, since the user would easily see the mistake</span>
<span class="sd">    in graphs of concentration over time (the alternative would be no</span>
<span class="sd">    reaction happening at all, which is rather cryptic to debug).</span>

<span class="sd">    &gt;&gt;&gt; parse_reactions(&quot;A -&gt; A‡ -&gt; A&#39;‡ -&gt; B&quot;)</span>
<span class="sd">    Scheme(compounds=(&#39;A&#39;, &#39;A‡&#39;, &quot;A&#39;‡&quot;, &#39;B&#39;),</span>
<span class="sd">           reactions=(&quot;A -&gt; A&#39;‡&quot;,),</span>
<span class="sd">           is_half_equilibrium=(False,),</span>
<span class="sd">           A=((-1.,), (0.,), (1.,), (0.,)),</span>
<span class="sd">           B=((-1.,), (1.,), (0.,), (0.,)))</span>

<span class="sd">    In any case, it&#39;s not clear how a reaction barrier be defined in such a</span>
<span class="sd">    case. If you have a use case, don&#39;t hesitate to</span>
<span class="sd">    [open an issue](https://github.com/geem-lab/overreact/issues/), we&#39;ll be</span>
<span class="sd">    happy to hear from you.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">compounds</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Text</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">reactions</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span>
        <span class="nb">tuple</span><span class="p">[</span><span class="n">Text</span><span class="p">,</span> <span class="n">Text</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">Text</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Text</span><span class="p">],</span> <span class="o">...</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">A</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>  <span class="c1"># coefficients between reactants and products</span>
    <span class="n">B</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>  <span class="c1"># coefficients between reactants and transition states</span>

    <span class="k">def</span> <span class="nf">_add_reaction</span><span class="p">(</span><span class="n">reactants</span><span class="p">,</span> <span class="n">products</span><span class="p">,</span> <span class="n">is_half_equilibrium</span><span class="p">,</span> <span class="n">transition</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Local helper function with side-effects.&quot;&quot;&quot;</span>
        <span class="c1"># TODO(schneiderfelipe): what if reaction is defined, then redefined</span>
        <span class="c1"># as equilibrium, or vice-versa?</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">transition</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="p">(</span><span class="n">reactants</span><span class="p">,</span> <span class="n">products</span><span class="p">,</span> <span class="n">is_half_equilibrium</span><span class="p">,</span> <span class="n">transition</span><span class="p">)</span> <span class="ow">in</span> <span class="n">reactions</span>
        <span class="p">):</span>
            <span class="k">return</span>

        <span class="c1"># found new reaction</span>
        <span class="n">reactions</span><span class="p">[(</span><span class="n">reactants</span><span class="p">,</span> <span class="n">products</span><span class="p">,</span> <span class="n">is_half_equilibrium</span><span class="p">,</span> <span class="n">transition</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">A_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">compounds</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">coefficient</span><span class="p">,</span> <span class="n">reactant</span> <span class="ow">in</span> <span class="n">reactants</span><span class="p">:</span>
            <span class="n">A_vector</span><span class="p">[</span><span class="n">compounds</span><span class="p">[</span><span class="n">reactant</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="n">coefficient</span>
        <span class="n">B_vector</span> <span class="o">=</span> <span class="n">A_vector</span>

        <span class="k">if</span> <span class="n">transition</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">B_vector</span> <span class="o">=</span> <span class="n">A_vector</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># it&#39;s assumed that</span>
            <span class="c1">#   1. there&#39;s a singe transition compound, and</span>
            <span class="c1">#   2. its coefficient equals one</span>
            <span class="n">B_vector</span><span class="p">[</span><span class="n">compounds</span><span class="p">[</span><span class="n">transition</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]]]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">coefficient</span><span class="p">,</span> <span class="n">product</span> <span class="ow">in</span> <span class="n">products</span><span class="p">:</span>
            <span class="n">A_vector</span><span class="p">[</span><span class="n">compounds</span><span class="p">[</span><span class="n">product</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">coefficient</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">is_half_equilibrium</span>
            <span class="ow">and</span> <span class="p">(</span><span class="n">products</span><span class="p">,</span> <span class="n">reactants</span><span class="p">,</span> <span class="n">is_half_equilibrium</span><span class="p">,</span> <span class="n">transition</span><span class="p">)</span> <span class="ow">in</span> <span class="n">reactions</span>
        <span class="p">):</span>
            <span class="n">B_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">compounds</span><span class="p">))</span>

        <span class="n">A</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A_vector</span><span class="p">)</span>
        <span class="n">B</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">B_vector</span><span class="p">)</span>

    <span class="n">after_transitions</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span>
        <span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Text</span><span class="p">],</span> <span class="o">...</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Text</span><span class="p">]]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">before_transitions</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span>
        <span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Text</span><span class="p">],</span> <span class="o">...</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Text</span><span class="p">]]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">reactants</span><span class="p">,</span> <span class="n">products</span><span class="p">,</span> <span class="n">is_half_equilibrium</span> <span class="ow">in</span> <span class="n">_parse_reactions</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">reactants</span><span class="p">,</span> <span class="n">products</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">in</span> <span class="n">reactions</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="n">reactants</span><span class="p">,</span>
            <span class="n">products</span><span class="p">,</span>
            <span class="kc">True</span><span class="p">,</span>
            <span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span> <span class="ow">in</span> <span class="n">reactions</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">compound</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">reactants</span><span class="p">,</span> <span class="n">products</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">compound</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">compounds</span><span class="p">:</span>
                <span class="c1"># found new compound</span>
                <span class="n">compounds</span><span class="p">[</span><span class="n">compound</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">compounds</span><span class="p">)</span>

        <span class="c1"># TODO(schneiderfelipe): what if a transition state is used in an</span>
        <span class="c1"># equilibrium?</span>

        <span class="c1"># it&#39;s assumed that if a transition shows up,</span>
        <span class="c1">#   1. it&#39;s the only compound in its side of the reaction, and</span>
        <span class="c1">#   2. its coefficient equals one</span>
        <span class="k">if</span> <span class="n">is_transition_state</span><span class="p">(</span><span class="n">reactants</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">before_reactants</span> <span class="ow">in</span> <span class="n">before_transitions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">reactants</span><span class="p">,</span> <span class="p">[]):</span>
                <span class="n">_add_reaction</span><span class="p">(</span>
                    <span class="n">before_reactants</span><span class="p">,</span> <span class="n">products</span><span class="p">,</span> <span class="n">is_half_equilibrium</span><span class="p">,</span> <span class="n">reactants</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">reactants</span> <span class="ow">in</span> <span class="n">after_transitions</span><span class="p">:</span>
                <span class="n">after_transitions</span><span class="p">[</span><span class="n">reactants</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">products</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">after_transitions</span><span class="p">[</span><span class="n">reactants</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">products</span><span class="p">]</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">is_transition_state</span><span class="p">(</span><span class="n">products</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">after_products</span> <span class="ow">in</span> <span class="n">after_transitions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">products</span><span class="p">,</span> <span class="p">[]):</span>
                <span class="n">_add_reaction</span><span class="p">(</span><span class="n">reactants</span><span class="p">,</span> <span class="n">after_products</span><span class="p">,</span> <span class="n">is_half_equilibrium</span><span class="p">,</span> <span class="n">products</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">products</span> <span class="ow">in</span> <span class="n">before_transitions</span><span class="p">:</span>
                <span class="n">before_transitions</span><span class="p">[</span><span class="n">products</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reactants</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">before_transitions</span><span class="p">[</span><span class="n">products</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">reactants</span><span class="p">]</span>
            <span class="k">continue</span>

        <span class="n">_add_reaction</span><span class="p">(</span><span class="n">reactants</span><span class="p">,</span> <span class="n">products</span><span class="p">,</span> <span class="n">is_half_equilibrium</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Scheme</span><span class="p">(</span>
        <span class="n">compounds</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">compounds</span><span class="p">),</span>
        <span class="n">reactions</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">_unparse_reactions</span><span class="p">(</span><span class="n">reactions</span><span class="p">)),</span>
        <span class="n">is_half_equilibrium</span><span class="o">=</span><span class="n">rx</span><span class="o">.</span><span class="n">_misc</span><span class="o">.</span><span class="n">totuple</span><span class="p">([</span><span class="n">reaction</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">reaction</span> <span class="ow">in</span> <span class="n">reactions</span><span class="p">]),</span>
        <span class="n">A</span><span class="o">=</span><span class="n">rx</span><span class="o">.</span><span class="n">_misc</span><span class="o">.</span><span class="n">totuple</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">(</span>
                <span class="p">[[</span><span class="n">vector</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">compounds</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">vector</span><span class="p">))]</span> <span class="k">for</span> <span class="n">vector</span> <span class="ow">in</span> <span class="n">A</span><span class="p">]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="p">),</span>
        <span class="n">B</span><span class="o">=</span><span class="n">rx</span><span class="o">.</span><span class="n">_misc</span><span class="o">.</span><span class="n">totuple</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">(</span>
                <span class="p">[[</span><span class="n">vector</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">compounds</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">vector</span><span class="p">))]</span> <span class="k">for</span> <span class="n">vector</span> <span class="ow">in</span> <span class="n">B</span><span class="p">]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="p">),</span>
    <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Parse a kinetic model as a chemical reaction scheme.</p>

<p>This is an essential part of the parsing process.
See <code><a href="io.html#parse_model">overreact.io.parse_model</a></code> other details.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>text</strong> (str or sequence of str):
Model description or sequence of lines of it.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>scheme</strong> (Scheme):
A descriptor of the reaction scheme.</li>
</ul>

<h6 id="notes">Notes</h6>

<p>The model description should comply with the mini-language for systems of
reactions. A semi-formal definition of the grammar in
<a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">Backus–Naur form</a>
is given below:</p>

<pre><code>     equation ::= equation_side arrow equation_side
equation_side ::= coefficient compound ['+' coefficient compound]*
  coefficient ::= [integers] (defaults to 1)
     compound ::= mix of printable characters
        arrow ::= '-&gt;' | '&lt;=&gt;' | '&lt;-'
</code></pre>

<p>Blank lines and comments (starting with <code>//</code>) are ignored. Repeated
reactions are ignored. Furthermore, reactions can be chained one after
another and, if a single compound (with either a <code>‡</code> or a <code>#</code> at the end)
appears alone on one side of a reaction, it's considered a transition
state. Transition states have zero lifetime during the simulation.</p>

<h6 id="examples">Examples</h6>

<p>What follows is a rather long tour over the parsing process and its
output in general. You can skip it if you are not interested in the
details.</p>

<div class="codehilite"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">scheme</span> <span class="o">=</span> <span class="n">parse_reactions</span><span class="p">(</span><span class="s2">&quot;A -&gt; B  // a direct reaction&quot;</span><span class="p">)</span>
</code></pre></div>

<p>The reaction above is a direct one (observe that comments are ignored). The
returned object has the following attributes:</p>

<div class="codehilite"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">scheme</span><span class="o">.</span><span class="n">compounds</span>
<span class="go">(&#39;A&#39;, &#39;B&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scheme</span><span class="o">.</span><span class="n">reactions</span>
<span class="go">(&#39;A -&gt; B&#39;,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scheme</span><span class="o">.</span><span class="n">is_half_equilibrium</span>
<span class="go">(False,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scheme</span><span class="o">.</span><span class="n">A</span>
<span class="go">((-1.,), (1.,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scheme</span><span class="o">.</span><span class="n">B</span>
<span class="go">((-1.,), (1.,))</span>
</code></pre></div>

<p>The same reaction can be specified in reverse order:</p>

<div class="codehilite"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">parse_reactions</span><span class="p">(</span><span class="s2">&quot;B &lt;- A  // reverse reaction of the above&quot;</span><span class="p">)</span>
<span class="go">Scheme(compounds=(&#39;A&#39;, &#39;B&#39;),</span>
<span class="go">       reactions=(&#39;A -&gt; B&#39;,),</span>
<span class="go">       is_half_equilibrium=(False,),</span>
<span class="go">       A=((-1.,), (1.,)),</span>
<span class="go">       B=((-1.,), (1.,)))</span>
</code></pre></div>

<p>Equilibria produce twice as many direct reactions, while the $B$ matrix
defines an energy relationship for only one of each pair:</p>

<div class="codehilite"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">parse_reactions</span><span class="p">(</span><span class="s2">&quot;A &lt;=&gt; B  // an equilibrium&quot;</span><span class="p">)</span>
<span class="go">Scheme(compounds=(&#39;A&#39;, &#39;B&#39;),</span>
<span class="go">       reactions=(&#39;A -&gt; B&#39;, &#39;B -&gt; A&#39;),</span>
<span class="go">       is_half_equilibrium=(True, True),</span>
<span class="go">       A=((-1.,  1.),</span>
<span class="go">          (1., -1.)),</span>
<span class="go">       B=((-1.,  0.),</span>
<span class="go">          (1.,  0.)))</span>
</code></pre></div>

<p>Adding twice the same reaction results in a single reaction being added.
This of course also works with equilibria (extra whitespaces are ignored):</p>

<div class="codehilite"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">parse_reactions</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="s1">    A &lt;=&gt; B  -&gt; A</span>
<span class="gp">... </span><span class="s1">    A  -&gt; B &lt;=&gt; A</span>
<span class="gp">... </span><span class="s1">    A  -&gt; B &lt;-  A</span>
<span class="gp">... </span><span class="s1">    B &lt;-  A  -&gt; B</span>
<span class="gp">... </span><span class="s1">&#39;&#39;&#39;</span><span class="p">)</span>
<span class="go">Scheme(compounds=(&#39;A&#39;, &#39;B&#39;),</span>
<span class="go">       reactions=(&#39;A -&gt; B&#39;, &#39;B -&gt; A&#39;),</span>
<span class="go">       is_half_equilibrium=(True, True),</span>
<span class="go">       A=((-1.,  1.),</span>
<span class="go">          (1., -1.)),</span>
<span class="go">       B=((-1.,  0.),</span>
<span class="go">          (1.,  0.)))</span>
</code></pre></div>

<p>Transition states are specified with a special symbol at the end (either
<code>‡</code> or <code>#</code>). They are shown among compounds, but the matrix $A$ ensures
they'll never have a non-zero rate of formation/consumption. On the other
hand, they are needed in the $B$ matrix:</p>

<div class="codehilite"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">parse_reactions</span><span class="p">(</span><span class="s2">&quot;A -&gt; A‡ -&gt; B&quot;</span><span class="p">)</span>
<span class="go">Scheme(compounds=(&#39;A&#39;, &#39;A‡&#39;, &#39;B&#39;),</span>
<span class="go">       reactions=(&#39;A -&gt; B&#39;,),</span>
<span class="go">       is_half_equilibrium=(False,),</span>
<span class="go">       A=((-1.,), (0.,), (1.,)),</span>
<span class="go">       B=((-1.,), (1.,), (0.,)))</span>
</code></pre></div>

<p>This gives the same result as above:</p>

<div class="codehilite"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">parse_reactions</span><span class="p">(</span><span class="s2">&quot;A -&gt; A‡ -&gt; B &lt;- A‡ &lt;- A&quot;</span><span class="p">)</span>
<span class="go">Scheme(compounds=(&#39;A&#39;, &#39;A‡&#39;, &#39;B&#39;),</span>
<span class="go">       reactions=(&#39;A -&gt; B&#39;,),</span>
<span class="go">       is_half_equilibrium=(False,),</span>
<span class="go">       A=((-1.,), (0.,), (1.,)),</span>
<span class="go">       B=((-1.,), (1.,), (0.,)))</span>
</code></pre></div>

<p>It is possible to define a reaction whose product is the same as the
reactant. This is found in isomerization processes (e.g., ammonia
inversion or the methyl rotation in ethane):</p>

<div class="codehilite"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">parse_reactions</span><span class="p">(</span><span class="s2">&quot;S -&gt; E‡ -&gt; S&quot;</span><span class="p">)</span>
<span class="go">Scheme(compounds=(&#39;S&#39;, &#39;E‡&#39;),</span>
<span class="go">       reactions=(&#39;S -&gt; S&#39;,),</span>
<span class="go">       is_half_equilibrium=(False,),</span>
<span class="go">       A=((0.,), (0.,)),</span>
<span class="go">       B=((-1.,), (1.,)))</span>
</code></pre></div>

<p>As such, a column full of zeros in the $A$ matrix corresponds to a reaction
with zero net change. As can be seen, overreact allows for very general
models. An interesting feature is that a single transition state can link
many different compounds (whether it is useful is a matter of debate):</p>

<div class="codehilite"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">parse_reactions</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="s1">    B  -&gt; B‡  -&gt; C  // chained reactions and transition states</span>
<span class="gp">... </span><span class="s1">    B‡ -&gt; D         // this is a bifurcation</span>
<span class="gp">... </span><span class="s1">    B  -&gt; B&#39;‡ -&gt; E  // this is a classical competitive reaction</span>
<span class="gp">... </span><span class="s1">    A  -&gt; B‡</span>
<span class="gp">... </span><span class="s1">&#39;&#39;&#39;</span><span class="p">)</span>
<span class="go">Scheme(compounds=(&#39;B&#39;, &#39;B‡&#39;, &#39;C&#39;, &#39;D&#39;, &quot;B&#39;‡&quot;, &#39;E&#39;, &#39;A&#39;),</span>
<span class="go">       reactions=(&#39;B -&gt; C&#39;, &#39;B -&gt; D&#39;, &#39;B -&gt; E&#39;, &#39;A -&gt; C&#39;, &#39;A -&gt; D&#39;),</span>
<span class="go">       is_half_equilibrium=(False, False, False, False, False),</span>
<span class="go">       A=((-1., -1., -1.,  0.,  0.),</span>
<span class="go">          (0.,  0.,  0.,  0.,  0.),</span>
<span class="go">          (1.,  0.,  0.,  1.,  0.),</span>
<span class="go">          (0.,  1.,  0.,  0.,  1.),</span>
<span class="go">          (0.,  0.,  0.,  0.,  0.),</span>
<span class="go">          (0.,  0.,  1.,  0.,  0.),</span>
<span class="go">          (0.,  0.,  0., -1., -1.)),</span>
<span class="go">       B=((-1., -1., -1.,  0.,  0.),</span>
<span class="go">          (1.,  1.,  0.,  1.,  1.),</span>
<span class="go">          (0.,  0.,  0.,  0.,  0.),</span>
<span class="go">          (0.,  0.,  0.,  0.,  0.),</span>
<span class="go">          (0.,  0.,  1.,  0.,  0.),</span>
<span class="go">          (0.,  0.,  0.,  0.,  0.),</span>
<span class="go">          (0.,  0.,  0., -1., -1.)))</span>
</code></pre></div>

<p>The following is a borderline case but both reactions should be considered
different since they define different processes:</p>

<div class="codehilite"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">parse_reactions</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="s1">    A -&gt; A‡ -&gt; B</span>
<span class="gp">... </span><span class="s1">    A -&gt; B</span>
<span class="gp">... </span><span class="s1">&#39;&#39;&#39;</span><span class="p">)</span>
<span class="go">Scheme(compounds=(&#39;A&#39;, &#39;A‡&#39;, &#39;B&#39;),</span>
<span class="go">       reactions=(&#39;A -&gt; B&#39;, &#39;A -&gt; B&#39;),</span>
<span class="go">       is_half_equilibrium=(False, False),</span>
<span class="go">       A=((-1., -1.),</span>
<span class="go">          (0.,  0.),</span>
<span class="go">          (1.,  1.)),</span>
<span class="go">       B=((-1., -1.),</span>
<span class="go">          (1.,  0.),</span>
<span class="go">          (0.,  1.)))</span>
</code></pre></div>

<p>The following is correct behavior. In fact, the reactions are badly
defined: if more than one transition state are chained, the following
happens, which is correct since it's the most physically plausible model
that can be extracted. It can be seen as a feature that the product B is
ignored and not the reactant A, since the user would easily see the mistake
in graphs of concentration over time (the alternative would be no
reaction happening at all, which is rather cryptic to debug).</p>

<div class="codehilite"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">parse_reactions</span><span class="p">(</span><span class="s2">&quot;A -&gt; A‡ -&gt; A&#39;‡ -&gt; B&quot;</span><span class="p">)</span>
<span class="go">Scheme(compounds=(&#39;A&#39;, &#39;A‡&#39;, &quot;A&#39;‡&quot;, &#39;B&#39;),</span>
<span class="go">       reactions=(&quot;A -&gt; A&#39;‡&quot;,),</span>
<span class="go">       is_half_equilibrium=(False,),</span>
<span class="go">       A=((-1.,), (0.,), (1.,), (0.,)),</span>
<span class="go">       B=((-1.,), (1.,), (0.,), (0.,)))</span>
</code></pre></div>

<p>In any case, it's not clear how a reaction barrier be defined in such a
case. If you have a use case, don't hesitate to
<a href="https://github.com/geem-lab/overreact/issues/">open an issue</a>, we'll be
happy to hear from you.</p>
</div>


                </section>
    </main>
<script>
    function escapeHTML(html) {
        return document.createElement('div').appendChild(document.createTextNode(html)).parentNode.innerHTML;
    }

    const originalContent = document.querySelector("main.pdoc");
    let currentContent = originalContent;

    function setContent(innerHTML) {
        let elem;
        if (innerHTML) {
            elem = document.createElement("main");
            elem.classList.add("pdoc");
            elem.innerHTML = innerHTML;
        } else {
            elem = originalContent;
        }
        if (currentContent !== elem) {
            currentContent.replaceWith(elem);
            currentContent = elem;
        }
    }

    function getSearchTerm() {
        return (new URL(window.location)).searchParams.get("search");
    }

    const searchBox = document.querySelector(".pdoc input[type=search]");
    searchBox.addEventListener("input", function () {
        let url = new URL(window.location);
        if (searchBox.value.trim()) {
            url.hash = "";
            url.searchParams.set("search", searchBox.value);
        } else {
            url.searchParams.delete("search");
        }
        history.replaceState("", "", url.toString());
        onInput();
    });
    window.addEventListener("popstate", onInput);


    let search, searchErr;

    async function initialize() {
        try {
            search = await new Promise((resolve, reject) => {
                const script = document.createElement("script");
                script.type = "text/javascript";
                script.async = true;
                script.onload = () => resolve(window.pdocSearch);
                script.onerror = (e) => reject(e);
                script.src = "../search.js";
                document.getElementsByTagName("head")[0].appendChild(script);
            });
        } catch (e) {
            console.error("Cannot fetch pdoc search index");
            searchErr = "Cannot fetch search index.";
        }
        onInput();

        document.querySelector("nav.pdoc").addEventListener("click", e => {
            if (e.target.hash) {
                searchBox.value = "";
                searchBox.dispatchEvent(new Event("input"));
            }
        });
    }

    function onInput() {
        setContent((() => {
            const term = getSearchTerm();
            if (!term) {
                return null
            }
            if (searchErr) {
                return `<h3>Error: ${searchErr}</h3>`
            }
            if (!search) {
                return "<h3>Searching...</h3>"
            }

            window.scrollTo({top: 0, left: 0, behavior: 'auto'});

            const results = search(term);

            let html;
            if (results.length === 0) {
                html = `No search results for '${escapeHTML(term)}'.`
            } else {
                html = `<h4>${results.length} search result${results.length > 1 ? "s" : ""} for '${escapeHTML(term)}'.</h4>`;
            }
            for (let result of results.slice(0, 10)) {
                let doc = result.doc;
                let url = `../${doc.modulename.replaceAll(".", "/")}.html`;
                if (doc.qualname) {
                    url += `#${doc.qualname}`;
                }

                let heading;
                switch (result.doc.type) {
                    case "function":
                        heading = `<span class="def">${doc.funcdef}</span> <span class="name">${doc.fullname}</span><span class="signature">${doc.signature}:</span>`;
                        break;
                    case "class":
                        heading = `<span class="def">class</span> <span class="name">${doc.fullname}</span>`;
                        if (doc.bases)
                            heading += `<wbr>(<span class="base">${doc.bases}</span>)`;
                        heading += `:`;
                        break;
                    case "variable":
                        heading = `<span class="name">${doc.fullname}</span>`;
                        if (doc.annotation)
                            heading += `<span class="annotation">${doc.annotation}</span>`;
                        if (doc.default_value)
                            heading += `<span class="default_value">${doc.default_value}</span>`;
                        break;
                    default:
                        heading = `<span class="name">${doc.fullname}</span>`;
                        break;
                }
                html += `
                        <section class="search-result">
                        <a href="${url}" class="attr ${doc.type}">${heading}</a>
                        <div class="docstring">${doc.doc}</div>
                        </section>
                    `;

            }
            return html;
        })());
    }

    if (getSearchTerm()) {
        initialize();
        searchBox.value = getSearchTerm();
        onInput();
    } else {
        searchBox.addEventListener("focus", initialize, {once: true});
    }

    searchBox.addEventListener("keydown", e => {
        if (["ArrowDown", "ArrowUp", "Enter"].includes(e.key)) {
            let focused = currentContent.querySelector(".search-result.focused");
            if (!focused) {
                currentContent.querySelector(".search-result").classList.add("focused");
            } else if (
                e.key === "ArrowDown"
                && focused.nextElementSibling
                && focused.nextElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.nextElementSibling.classList.add("focused");
                focused.nextElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "ArrowUp"
                && focused.previousElementSibling
                && focused.previousElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.previousElementSibling.classList.add("focused");
                focused.previousElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "Enter"
            ) {
                focused.querySelector("a").click();
            }
        }
    });
</script></body>
</html>